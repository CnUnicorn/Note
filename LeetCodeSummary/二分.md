# 剑指offer 11. 旋转数组的最小数字

**通过二分法来查找最小值**

**有三种情况**：

1. 当pivot（也就是mid）小于high处的值时，说明**pivot在后面一段的递增序列上**，即最小值在pivot的左边或者在pivot上。将high移到pivot所在的位置，而不是pivot - 1的位置，因为pivot此时有可能是最小值。

<img src="https://assets.leetcode-cn.com/solution-static/jianzhi_11/2.png" alt="fig2" style="zoom:67%;" />



2. 当pivot处的值大于high处的值时，说明pivot位于前一段递增序列上，**由于前一段序列必定是递增的，所以pivot一定不可能是最小值**，将low移到pivot + 1的位置上。

   ![fig3](https://assets.leetcode-cn.com/solution-static/jianzhi_11/3.png)



3. 当pivot处的值等于high处的值时，由于可能会出现连续的序列，无法确定pivot在前半段还是在后半段，只能保证high这个点失效，high -= 1。

   不用low += 1来判断的理由是，在全递增的情况下可能会出现错误，比如[1, 2, 3, 4, 4, 4, 4]，第一次判断时，numbers[pivot] == numbers[high]，如果low += 1，那么就错过了最小值。

   ![fig4](https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png)

```java
class Solution {
    public int minArray(int[] numbers) {
        int low = 0, high = numbers.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (numbers[pivot] < numbers[high]) { // 当中间值小于high时，
                high = pivot;                     // 忽略pivot到high的所有数
            }else if (numbers[pivot] > numbers[high]) { // 当中间值大于high时，
                low = pivot + 1;                        // 忽略low到pivot的所有数
            }else {
                high -= 1;
            }
        }
        return numbers[low];

        // 另一种方法，从后向前遍历
        // for (int i = numbers.length-1; i >= 1; i--) 
		// 	if(numbers[i]<numbers[i-1])
		// 		return numbers[i];
		// return numbers[0];
    }
}
```

