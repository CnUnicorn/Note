# 242. 有效的字母异位词

**思路一：**

简单的逻辑，把两个字符串转换成char类型的数组 `String.toCharArray()` ，然后将两个数组排序，比较数组是否相等 `Arrays.equals(String a, String b)`。

注意点：如果两个字符串不一样长，必定不是异位词。所以要优先比较两个字符串的长度。



**思路二：**

由于这里是26个小写字母，所以可以直接分配固定大小的数组（长度26），字母对应数组下标为 `char - 'a'` （hash函数）。

**小技巧：** **可以不需要两个数组，只用一个数组就可以比较是否是异位词**。遍历两个字符串，字符串1中出现的字符在桶数组中加1，字符串2中出现的字符在桶数组中减1。最后遍历桶，如果桶中出现不为0的元素，那么说明字符出现的频率不同，不是异位词。

当字符串包含unicode字符时，使用哈希表（HashMap存储），而分配固定大小的数组。





# 349. 两个数组的交集

**最简单的思路（暴力求解）：**

遍历较小的那个数组，对每一个数，在较大的那个数组中遍历是否存在这个数，两个嵌套的for循环。

时间复杂度：O（n * m），n，m为两个数组的长度。



**自己的思路：**

仍然遍历较小的那个数组，对每一个数，在较大的数组中遍历是否存在这个数。

改用二分查找寻找是否存在这个数字。略微提升了效率。



**思路一：**

使用`Set`集合，这个数据结构。`Set`中的的`contains`方法操作的平均时间复杂度是O(1)。

思路仍然是先将输入的两个数组都转换成集合（集合中元素不重复），遍历较小的集合，使用`contains`方法判断小数组中的数是否存在于第二个数组中，相比自己的思路，提升了查找的效率（二分 ——> `contains`方法）。



**思路二：**排序 + 双指针

排序两个数组，两个指针 index1 和 index2 遍历两个数组，index 为存放交集的数组中最后一个数的后一个位置的指针。

三种情况：

* 两个数字相同时：
  * 如果是第一个相同的数，或者是和交集中最后一个数不同，将这个数存进交集数组中，将 index1 和 index2 全部向后移一位
  * 如果和交集最后一个数相同，不重复存数据，只把 index1 和 index2 向后移一位。
* 如果 index1 对应的数字小于 index2 对应的数字，将 index1 向右移一位
* 如果 index2 对应的数字小于 index1 对应的数字，将 index2 向右移一位



# 350. 两个数组的交集II

在349题的基础上，增加了新的约束。返回的结果中，可以出现重复的元素，出现次数为该元素在两个数组中出现次数的最小值。

**思路一：使用哈希表查询**

统计**较短数组**中元素出现的次数（实际上其中任意一个数组都可以放在HashMap中，统计较短数组是为了降低空间复杂度），存储在哈希表中。然后遍历较长的数组，如果较长数组中的元素在哈希表中存在，那么将这个元素添加到结果中，同时哈希表中的次数减一。如果不存在，不添加元素。（遍历时，每一个较长数组中的元素相当于出现次数1，和哈希表中元素的次数进行比较）



**思路二：排序**

将两个数组排序，给定两个指针，分别从两个数组头开始遍历，比较两个数组。

* 如果两个元素相同，添加到结果中，**并且两个指针同时加一**
* 如果元素不相同，较小元素的指针加一。
* 如果有一个指针超出数组范围，返回结果。



# 976. 三角形的最大周长

**最简单直接的思路：**

由于要求最大周长，所以我们希望三条边越长越好。首先想到先将数组排序，然后从最后面相邻的三个数开始判断 （a <= b <= c）。

如果要构成三角形，那么需要满足a + b > c。如果不满足这个条件，说明c太大了，三个数整体向左移一位（滑窗向左移一位），一旦满足a + b > c，那么这个三角形的周长就是最大周长。

**当时迷惑的地方**：

为何要整体向左移，即抛弃滑窗中当前的最大值。如果不满足三角形构成条件，那么说明a+b比c小，又由于数组是排序的，如果只把a和b向左移，那么必定仍然不满三角形构成条件。所以要整体向左移，才有可能构成三角形。



**总结：**

* 为了周长最大，三条边尽可能大，即三个数相邻
* 由于数组已排序，如果不满足三角形构成条件，说明最大边太大，所以整体向左移才可能构成三角形



# 1370.  上升下降字符串

**题解思路：（桶）**

1. 将字符串中每个字符出现的次数保存在一个数组里，由于是char类型，可以使用ascii码进行下标转换。

   a — z字符在数组中的下标等于 `'c' - 'a'` ，转换后，26个字符分别对应下标0-25。

2. 遍历整个字符串，把所有字符的次数存储到数组中（一个数组就完成了Map的功能，利用ascii码将字符转换成了下标）。

3. 遍历上述数组（桶），前向遍历一次和反向遍历一次为一次循环。只要数组中存储的次数不为0，就向结果字符串中（StringBuilder）添加该字符，然后存储的次数减一。



个人理解：

​	题目逻辑实际上是：先从将字符串中的字符按从小到大的顺序取出来，再将字符串剩下的字符按从大到小的顺序取出来，重复的字符只取一次。不断重复上面的操作，直到所有的字符全部按以上的逻辑排序（只有字符串中有重复的字符的时候，才需要重复上面的操作，不然一次就可以把所有的字符取出来）。

​	遍历桶的操作正好符合上面的逻辑：

* 正向遍历桶就是把所有的字符从小到大取

* 反向遍历桶就是把所有字符从大到小取
* 同时保证重复的字符一次只取一次（取完之后，存储的次数减一）



# 1403. 非递增顺序的最小子序列

简单的逻辑，把数组排序并求数组的和，从后面向前遍历，统计子序列的和，判断是否严格大于剩下数，不大于则将数组元素添加进列表，并且增加子序列的和。

实现细节：判断子序列的和是否大于数组剩余元素的和时，判断条件可以选择 **2 * 子序列和 > 原数组所有元素的和** ，因为原数组已经排序过了，且要求严格大于，所以从后向前遍历时，如果子序列的两倍大于原数组所有元素的和，子序列必定大于剩下的元素和（由于要求严格大于，所以两倍子序列和不可以等于原数组的和，否则子序列等于剩下元素的和）。



# 1122. 数组的相对排序

和 **1370. 上升下降字符串** 思路相同，也是用“桶”去存放其中一个数组元素出现的次数，然后根据另一个数组中的元素在这个数组中做查询。

**空间换时间**：

由于题目中的条件 **arr1.length,arr2.length <= 1000; 0 <= arr1[i],arr2[i] <= 1000** ，所以可以直接把arr1中的数值散列成一个数组的下标（创建一个1001长度的数组）。用这个大数组去记录arr1中所有元素出现的次数。

逻辑思路：

1. 先统计arr1中所有元素的出现的次数，存放在一个长度为1001的大数组中（因为数值最大有1000，所以数组长度需要1001，下标达到1000）
2. 遍历arr2中的元素，由于直接将数值散列成键（大数组下标），所以直接根据数值访问大数组，得到元素次数。添加相应次数的元素到结果数组中
3. 此时arr1中，剩下的不为0的元素下标即为arr2中不存在的数，由于散列的原因，自动排好了顺序，只要遍历剩下的不为0的元素，添加相应次数的元素到结果数组中即可。



# 922. 按奇偶排序II

**思路一：**

最简单的思路，创建额外的空间，遍历一遍数组，将奇数存到奇数下标，将偶数存到偶数下标。

**思路二：双指针**

先遍历下标为偶数的元素，遇到一个奇数时，遍历下标为奇数的元素，寻找第一个下标为奇数的偶数，然后交换两个数。（偶数与奇数的下标需要保留，从交换的位置开始继续向后遍历）。

这种方法不需要开辟额外的空间。



# 1030. 距离顺序排列矩阵单元格

逻辑思路：

根据曼哈顿距离（两单元格`(r1, c1)` 和 `(r2, c2)` 之间的距离是曼哈顿距离，`|r1 - r2| + |c1 - c2|`）可知，与给定点相同距离的点可能有很多个。

使用散列（或者说“桶”）的思想，将距离直接散列成索引下标（距离=数组下标），数组中每个元素为一个链表（**散列表中的拉链法**），存储所有相同距离的点的信息（存放一个数组，或者存放一个对象（Node））。

存放所有点的信息之后，再去将数据从小到大读出来（由于拉链法的数组下标=距离，所以存放完数据之后，已经完成了排序的工作）。



**注意点：**

**foreach循环，实际上使用了一个新指针指向数组中的元素，用foreach无法正确为数组中的元素new新的对象，new出来的新对象的指针没有赋给数组中的元素，而是赋给了foreach中的临时的指针**

```java
int[] arr = {1, 2, 3, 4, 5};
for (int i:arr) {
    i = 3;
}
// i是一个新的指针，把3赋值给i，或者把一个对象赋给foreach中的变量，只是相当于把i指向了一个新的指针
```



**泛型数组赋值：**

```java
LinkedList<Integer>[] list = (LinkedList<Intger>[]) new LinkedList[3];
for (int i = 0;i < 3;i++) {
    list[i] = new LinkedList<>();
}
// new数组的时候，泛型变量不需要写，会被擦除，直接强转成想要的泛型数组
```



# 1365. 有多少小于当前数字的数字

思路一：暴力解

两个for循环，暴力比较小于这个数的数量

时间复杂度：N平方



思路二：桶排序

题目里限制了，值大于等于0，小于等于100，所以可以创建一个101长度的数组，下标为数组值索引，数组中存放对应的出现次数。

桶排序之后，从第一个数开始，把前一个数出现的次数叠加在自己的次数上，这样遍历一遍桶之后，每一个数值索引存放的值为：**小于他的值的数量 + 这个值出现的次数**（所以**小于某个数的数字的数量 = 桶[索引 - 1]**）

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] bucket = new int[101];
        int[] result = new int[nums.length];
        for (int i = 0;i < nums.length;i++) {
            bucket[nums[i]] += 1;
        }

        for (int i = 1;i < bucket.length;i++) { 
            // bucket中存储的数值是小于等于下标的数的个数
            bucket[i] += bucket[i-1];
        }

        for(int i = 0;i < nums.length;i++) {
            // 数值等于0的时候，必定没有小于他的数值
            result[i] = nums[i] == 0 ? 0 : bucket[nums[i] - 1];
        }

        return result;
    }
}
```



# 剑指offer 04. 二维数组中的查找

思路是：

从数组的右上角开始查找，左边的数比当前位置的数字小，下边的数比当前位置的数字大（也可以看成是一颗斜着的二叉树搜索树，右上角的数为根节点，左边比它小，右边比它大）。

* 如果目标数字比当前位置的数字小，那么当前位置的数字向左移动一格（因为下面的数字比当前数字大，只可能在左边查找到目标数字）
* 如果目标数字比当前位置的数字大，那么当前位置的数字向下移动一格（因为左边的数字比当前的数字小，只可能在下面查找到目标数字）



从左下角查找也可以，上面的数字比当前位置的数字小，右边的数字比当前位置的数字大。

从左上角和右下角无法实现查找。

* 左上角：右边和下面的数字都比当前位置的数字大，没法判断走下面还是走右边
* 右下角：左边和上面的数字都比当前位置的数字小，没法判断走上面还是走左边

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        // 避免null、[]和[[]]的情况
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int n = matrix.length, m = matrix[n - 1].length;
        int row = 0,column = m - 1;
        while (row < n && column >= 0) {
            if (matrix[row][column] < target) {
                row++;
            }
            else if (matrix[row][column] > target) {
                column--;
            }
            else {
                return true;
            }
        }
        return false;
    }
}
```

