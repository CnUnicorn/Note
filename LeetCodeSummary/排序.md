# 242. 有效的字母异位词

**思路一：**

简单的逻辑，把两个字符串转换成char类型的数组 `String.toCharArray()` ，然后将两个数组排序，比较数组是否相等 `Arrays.equals(String a, String b)`。

注意点：如果两个字符串不一样长，必定不是异位词。所以要优先比较两个字符串的长度。



**思路二：**

使用哈希表（待定）。



# 349. 两个数组的交集

**最简单的思路（暴力求解）：**

遍历较小的那个数组，对每一个数，在较大的那个数组中遍历是否存在这个数，两个嵌套的for循环。

时间复杂度：O（n * m），n，m为两个数组的长度。



**自己的思路：**

仍然遍历较小的那个数组，对每一个数，在较大的数组中遍历是否存在这个数。

改用二分查找寻找是否存在这个数字。略微提升了效率。



**思路一：**

使用`Set`集合，这个数据结构。`Set`中的的`contains`方法操作的平均时间复杂度是O(1)。

思路仍然是先将输入的数组转换成集合，遍历较小的集合，使用`contains`方法判断小数组中的数是否存在于第二个数组中，相比自己的思路，提升了查找的效率（二分 ——> `contains`方法）。



# 350. 两个数组的交集II

在349题的基础上，增加了新的约束。返回的结果中，可以出现重复的元素，出现次数为改元素在两个数组中出现次数的最小值。

**思路一：使用哈希表查询**

统计较短数组中元素出现的次数，存储在哈希表中。然后遍历较长的数组，如果较长数组中的元素在哈希表中存在，那么将这个元素添加到结果中，同时哈希表中的次数减一。如果不存在，不添加元素。（遍历时，每一个较长数组中的元素相当于出现次数1，和哈希表中元素的次数进行比较）



**思路二：排序**

将两个数组排序，给定两个指针，分别从两个数组头开始遍历，比较两个数组。

* 如果两个元素相同，添加到结果中，**并且两个指针同时加一**
* 如果元素不相同，较小元素的指针加一。
* 如果有一个指针超出数组范围，返回结果。



# 976. 三角形的最大周长

**最简单直接的思路：**

由于要求最大周长，所以我们希望三条边越长越好。首先想到先将数组排序，然后从最后面相邻的三个数开始判断 （a <= b <= c）。

如果要构成三角形，那么需要满足a + b > c。如果不满足这个条件，说明c太大了，三个数整体向左移一位（滑窗向左移一位），一旦满足a + b > c，那么这个三角形的周长就是最大周长。

**当时迷惑的地方**：

为何要整体向左移，即抛弃滑窗中当前的最大值。如果不满足三角形构成条件，那么说明a+b比c小，又由于数组是排序的，如果只把a和b向左移，那么必定仍然不满三角形构成条件。所以要整体向左移，才有可能构成三角形。



**总结：**

* 为了周长最大，三条边尽可能大，即三个数相邻
* 由于数组已排序，如果不满足三角形构成条件，说明最大边太大，所以整体向左移才可能构成三角形



# 1370.  上升下降字符串

**题解思路：（桶）**

1. 将字符串中每个字符出现的次数保存在一个数组里，由于是char类型，可以使用ascii码进行下标转换。

   a — z字符在数组中的下标等于 `'c' - 'a'` ，转换后，26个字符分别对应下标0-25。

2. 遍历整个字符串，把所有字符的次数存储到数组中（一个数组就完成了Map的功能，利用ascii码将字符转换成了下标）。

3. 遍历上述数组（桶），前向遍历一次和反向遍历一次为一次循环。只要数组中存储的次数不为0，就向结果字符串中（StringBuilder）添加该字符，然后存储的次数减一。



个人理解：

​	题目逻辑实际上是：先从将字符串中的字符按从小到大的顺序取出来，再将字符串剩下的字符按从大到小的顺序取出来，重复的字符只取一次。不断重复上面的操作，直到所有的字符全部按以上的逻辑排序（只有字符串中有重复的字符的时候，才需要重复上面的操作，不然一次就可以把所有的字符取出来）。

​	遍历桶的操作正好符合上面的逻辑：

* 正向遍历桶就是把所有的字符从小到大取

* 反向遍历桶就是把所有字符从大到小取
* 同时保证重复的字符一次只取一次（取完之后，存储的次数减一）