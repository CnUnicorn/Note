# 剑指Offer 18.删除链表节点

前提：链表种不存在重复的值，所以遍历到匹配值就可以直接返回节点了。

**注意点：**头节点匹配和中间节点匹配，删除处理不同。

**思考：**如果要删除链表种所以值匹配的节点？

* 先使用一个while循环做头节点匹配，如果头节点一直匹配，就一直删除，一直到没有节点或者值不匹配为止
* 再做剩下的节点匹配



1. **原题题解（没有重复值的情况）：**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode deleteNode(ListNode head, int val) {
           if (head.val == val) {
               head = head.next;
               return head;
           }
   
           ListNode pre = null, current = head; // 保留head指针，方便返回
           while (current != null) {
               if (current.val == val) {
                   pre.next = current.next;
                   return head;
               }
               pre = current;
               current = current.next;
           }
           return head;
       }
   }
   ```

   

2. **链表中有重复值的时候：**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode deleteNode(ListNode head, int val) {
           // 做头节点匹配，如果匹配，就删除节点，不匹配或者节点删完了，退出循环
           while (head != null) {
               if (head.val == val) {
                   head = head.next;
                   continue;
               }
               break;
           }
   		
           // 匹配剩下的节点，遍历剩下所有节点
           ListNode pre = head, current = head.next; // 保留head指针，方便返回
           while (current != null) {
               if (current.val == val) {
                   pre.next = current.next;
               }
               pre = current;
               current = current.next;
           }
           return head;
       }
   }
   ```




# 剑指Offer 22. 链表中倒数第k个节点

**思路：**

双指针，第一个指针先走k步，然后第二个指针跟着第一个指针一起走。

**需要注意的几个点：**

* k大于链表长度的时候
* 头节点为空或者k为0的时候

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if (head == null || k == 0) return null; // 当头节点为空或k为0时，返回null
        ListNode scout = head, res = head;
        for (int i = 0;i < k;i++) {
            if (scout == null) return null; // 当k大于链表长度的时候，返回null
            scout = scout.next;
        }
        while (scout != null) {
            scout = scout.next;
            res = res.next;
        }
        return res;
    }
}
```



# 剑指Offer 35.复杂链表的复制

**方法一：**使用HashMap，构建原链表节点和新链表节点的一一映射关系，比较直观

时间复杂度：O(N)，遍历两轮原链表

空间复杂度：O(N)，哈希表使用额外的线性空间，和节点数成正比

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> map = new HashMap<>(); // 将原链表指针和新链表指针构建一一映射关系，存放在HashMap中
        Node curr = head;
        // 1. 构建原链表和新链表的一一映射关系，存放在HashMap中
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }
        // 2. 再遍历一遍原链表，建立新链表的next和random指向关系
        curr = head;
        while (curr != null) {
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        // 3. 返回新链表的头节点
        return map.get(head);
    }
}
```



**方法二：**将原链表节点和新链表节点拼接成一条新的链表，用这种方式来确定random指针指向的节点

即新链表的结构为：原节点1 ——> 新节点1 ——> 原节点2 ——> 新节点2 ······

这样拼接后：新节点.random = 原节点.ramdom.next（即新节点一定跟在原节点后面），需要排除原节点random指向null的情况，因为null.next会报空指针异常，这种情况就不需要处理，新节点random默认就指向null。

时间复杂度：O(N)，遍历三次链表

空间复杂度：O(1)

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        
        Node curr = head;
        while (curr != null) { // 拼接原链表结点和新链表节点，构建新链表
            Node tmp = new Node(curr.val);
            tmp.next = curr.next;
            curr.next = tmp;
            curr = curr.next.next;
        }

        curr = head;
        while (curr != null) { // 确定新节点中random指针的指向
            if (curr.random != null) // 只有random指针不为null时，才确定新节点的指向，否则会报空指针异常，因为curr.random为null
                curr.next.random = curr.random.next;
            curr = curr.next.next;
        }

        curr = head.next;
        Node pre = head, res = head.next;
        // 拆分原链表和新链表
        while (curr.next != null) { // 这里判断条件设置为res.next != null，是因为，遍历到最后一个节点时，res下一个节点为null，如果继续循环，res.next.next会报空指针异常
            pre.next = pre.next.next;
            curr.next = curr.next.next;
            pre = pre.next;
            curr = curr.next;
        }
        pre.next = null; // 上面遍历完之后，原链表最后一个节点仍然指向新链表最后一个节点，这里单独处理
        return res;
    }
}
```



# 剑指Offer 36. 二叉搜索树与双向链表

思路与**BiNode**这道题一摸一样，利用**BST的中序遍历的有序性**。BiNode将二叉搜索树按顺序改成单向链表，这道题将二叉搜索树改成双向链表，只需要另外做尾节点和头节点的处理即可。

自己的写法，**将头节点保存在head.right中**：

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    // head是一个用来保存头节点指针的节点，head.right是头节点
    private Node head = new Node(0),  pre = null;

    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        helper(root);
        pre.right = head.right; // 尾节点指向头节点
        head.right.left = pre;  // 头节点指向尾节点
        return head.right;
    }
    /*
    // 这是好理解的写法
    public void helper(Node root) {
        if (root == null) return;
        
        helper(root.left);
        if (pre == null) { // pre为null时，表示正在访问第一个节点（最小的节点）
            pre = root;
            head.right = pre;
        }else {
            pre.right = root;
            root.left = pre;
        }
        pre = root;
        helper(root.right);
    }
    */
    
    // 这是代码优化后的写法
    public void helper(Node root) {
        if (root == null) return;
        
        helper(root.left);
        if (pre == null) { // 第一个节点（最小的节点）
            head.right = root;
        }else {
            pre.right = root;
        }
        root.left = pre;
        pre = root;
        helper(root.right);
    }
}
```



题解写法，头节点直接用一个指针保存：

```java
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    void dfs(Node cur) {
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur; // pre为空时，访问第一个节点，cur.left = pre正好让头节点的左指针为null
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

