# 剑指Offer 18.删除链表节点

前提：链表中不存在重复的值，所以遍历到匹配值就可以直接返回节点了。

**注意点：**头节点匹配和中间节点匹配，删除处理不同。

**思考：**如果要删除链表中所以值匹配的节点？

* 先使用一个while循环做头节点匹配，如果头节点一直匹配，就一直删除，一直到没有节点或者值不匹配为止
* 再做剩下的节点匹配



1. **原题题解（没有重复值的情况）：**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode deleteNode(ListNode head, int val) {
           if (head.val == val) {
               head = head.next;
               return head;
           }
   
           ListNode pre = null, current = head; // 保留head指针，方便返回
           while (current != null) {
               if (current.val == val) {
                   pre.next = current.next;
                   return head;
               }
               pre = current;
               current = current.next;
           }
           return head;
       }
   }
   ```

   

2. **链表中有重复值的时候：**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode deleteNode(ListNode head, int val) {
           // 做头节点匹配，如果匹配，就删除节点，不匹配或者节点删完了，退出循环
           while (head != null) {
               if (head.val == val) {
                   head = head.next;
                   continue;
               }
               break;
           }
   		
           // 匹配剩下的节点，遍历剩下所有节点
           ListNode pre = head, current = head.next; // 保留head指针，方便返回
           while (current != null) {
               if (current.val == val) {
                   pre.next = current.next;
               }
               pre = pre.next;             
               current = pre.next.next;
           }
           return head;
       }
   }
   ```




# 剑指Offer 22. 链表中倒数第k个节点

**思路：**

双指针，第一个指针先走k步，然后第二个指针跟着第一个指针一起走。

**需要注意的几个点：**

* k大于链表长度的时候
* 头节点为空或者k为0的时候

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if (head == null || k == 0) return null; // 当头节点为空或k为0时，返回null
        ListNode scout = head, res = head;
        for (int i = 0;i < k;i++) {
            if (scout == null) return null; // 当k大于链表长度的时候，返回null
            scout = scout.next;
        }
        while (scout != null) {
            scout = scout.next;
            res = res.next;
        }
        return res;
    }
}
```



# Hot100-19. 删除链表倒数第N个节点

创建一个无意义的节点指向头节点，满指针从无意义的节点触发，最后删除完节点后，$dummy.next$就是新的头节点（创建一个无意义的头节点，同时考虑到了删除头节点和删除最后一个节点的情况）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head); // 新建一个无意义的节点，指向头节点
        ListNode fast = head, low = dummy;
        int cnt = 0;
        while (fast != null) {
            if (cnt < n) {
                fast = fast.next;
                cnt++;
                continue;
            }
            fast = fast.next;
            low = low.next;
        }
        low.next = low.next.next; // 删除节点
        return dummy.next;
    }
}
```



# 剑指Offer 35.复杂链表的复制

**方法一：**使用HashMap，构建原链表节点和新链表节点的一一映射关系，比较直观

时间复杂度：O(N)，遍历两轮原链表

空间复杂度：O(N)，哈希表使用额外的线性空间，和节点数成正比

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> map = new HashMap<>(); // 将原链表指针和新链表指针构建一一映射关系，存放在HashMap中
        Node curr = head;
        // 1. 构建原链表和新链表的一一映射关系，存放在HashMap中
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }
        // 2. 再遍历一遍原链表，建立新链表的next和random指向关系
        curr = head;
        while (curr != null) {
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        // 3. 返回新链表的头节点
        return map.get(head);
    }
}
```



**方法二：**将原链表节点和新链表节点拼接成一条新的链表，用这种方式来确定random指针指向的节点

即新链表的结构为：原节点1 ——> 新节点1 ——> 原节点2 ——> 新节点2 ······

这样拼接后：新节点.random = 原节点.ramdom.next（即新节点一定跟在原节点后面），需要排除原节点random指向null的情况，因为null.next会报空指针异常，这种情况就不需要处理，新节点random默认就指向null。

时间复杂度：O(N)，遍历三次链表

空间复杂度：O(1)

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        
        Node curr = head;
        while (curr != null) { // 拼接原链表结点和新链表节点，构建新链表
            Node tmp = new Node(curr.val);
            tmp.next = curr.next;
            curr.next = tmp;
            curr = curr.next.next;
        }

        curr = head;
        while (curr != null) { // 确定新节点中random指针的指向
            if (curr.random != null) // 只有random指针不为null时，才确定新节点的指向，否则会报空指针异常，因为curr.random为null
                curr.next.random = curr.random.next;
            curr = curr.next.next;
        }

        curr = head.next;
        Node pre = head, res = head.next;
        // 拆分原链表和新链表
        while (curr.next != null) { // 这里判断条件设置为res.next != null，是因为，遍历到最后一个节点时，res下一个节点为null，如果继续循环，res.next.next会报空指针异常
            pre.next = pre.next.next; // while循环判断条件的另一种理解，pre和curr实际上是一对的，即旧节点和新节点
            curr.next = curr.next.next;
            pre = pre.next;
            curr = curr.next;
        }
        pre.next = null; // 上面遍历完之后，原链表最后一个节点仍然指向新链表最后一个节点，这里单独处理
        return res;
    }
}
```



# 剑指Offer 36. 二叉搜索树与双向链表

思路与**BiNode**这道题一摸一样，利用**BST的中序遍历的有序性**。BiNode将二叉搜索树按顺序改成单向链表，这道题将二叉搜索树改成双向链表，只需要另外做尾节点和头节点的处理即可。

自己的写法，**将头节点保存在head.right中**：

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    // head是一个用来保存头节点指针的节点，head.right是头节点
    private Node head = new Node(0),  pre = null;

    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        helper(root);
        // pre最后指向二叉树中最大的那个节点
        pre.right = head.right; // 尾节点右指针指向头节点
        head.right.left = pre;  // 头节点左指针指向尾节点，构成环形链表
        return head.right;
    }
    /*
    // 这是好理解的写法
    public void helper(Node root) {
        if (root == null) return;
        
        helper(root.left);
        if (pre == null) { // pre为null时，表示正在访问第一个节点（最小的节点）
            pre = root;
            head.right = pre;
        }else {
            pre.right = root;
            root.left = pre;
        }
        pre = root;
        helper(root.right);
    }
    */
    
    // 这是代码优化后的写法
    public void helper(Node root) {
        if (root == null) return;
        
        helper(root.left);
        if (pre == null) { // 第一个节点（最小的节点）
            head.right = root;
        }else {
            pre.right = root;
        }
        root.left = pre;
        pre = root;
        helper(root.right);
    }
}
```



题解写法，头节点直接用一个指针保存：

```java
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    void dfs(Node cur) {
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur; // pre为空时，访问第一个节点，cur.left = pre正好让头节点的左指针为null
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# 剑指offer 25. 合并两个排序的链表



使用一个无意义的头节点（dum节点）来保存头节点，

使用一个cur指针来保存上一个最小值的节点的指针，然后 l1 和 l2 指向的就是当前的两个节点，然后让cur指向其中值较小的节点即可。

**使用了额外的cur指针来保存上一个节点，就不用害怕丢失指向下一个节点的指针了。**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        
        ListNode dum = new ListNode(0), cur = dum;
        while ((l1 != null) && (l2 != null)) { // 其中一个头节点为空时，跳出循环
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
                //cur = cur.next;
            }
            else {
                cur.next = l2;
                l2 = l2.next;
                //cur = cur.next;
            }
            cur = cur.next;
        }

        cur.next = (l1 == null) ? l2 : l1; // 指向不为空的剩下的节点，如果两者都为空，指向null
        return dum.next;
        
    }
}
```



# Hot100-23. 合并k个升序链表

这道题实际上是建立在合并两条排序列表基础之上。

最简单的方法就是：从头开始，两两合并链表

使用分治的思想去优化：合并次数从n次，降低到了logn次，n为链表数组的长度

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int l, int r) {
        // 使用分治的思想合并，时间复杂度为O(knlogk)
        if (l == r) return lists[l];
        int mid = l + (r - l) / 2;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 合并两个升序链表的函数
        ListNode dum = new ListNode(-1), cur = dum;
        while ((l1 != null) && (l2 != null)) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            }
            else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }

        cur.next = (l1 == null) ? l2 : l1;
        return dum.next;
    }
}
```



# 剑指offer 52. 两个链表的第一个公共节点

使用两个指针遍历两个链表

* 当第一个指针遍历到链表尾部时，将这个指针指向第二个链表的头节点
* 第二个指针也是如此
* 理由：如果存在公共节点，第二次遍历的时候，一定会相遇，因为在此之前，他们走过的路程是完全相同的



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode node1 = headA, node2 = headB;

        while (node1 != node2) {
            node1 = node1 != null ? node1.next : headB; // 把最后的null也计算进去，如果两个链表没有公共节点，那么在null处相遇
            node2 = node2 != null ? node2.next : headA;
        }

        return node1;
    }
}
```



# Hot100-2. 两数相加

因为链表已经是倒序的了，所以，相当于是直接从低位开始相加，只需要使用一个整数 n 来保存低位的进位即可。

分四种情况：

1. l1为空，l2不为空
2. l1不为空，l2为空
3. l1和l2全不为空
4. l1和l2全为空，但是上一位求和还有进位（**这一种情况体现在while的判断条件中的n != 0**）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(-1), cur = head; // 使用一个head无意义的头节点来保存指向第一个节点的指针
        int n = 0; // n用来保存低位相加后的进位
        while(l1 != null || l2 != null || n != 0) { // 当最高位加完后还有进位，还有再继续创建节点，所以循环条件中有n != 0
            if (l1 == null && l2 != null) {
                cur.next = new ListNode((l2.val + n) % 10);
                n = (l2.val + n) / 10; 
            }
            else if (l1 != null && l2 == null) {
                cur.next = new ListNode((l1.val + n) % 10);
                n = (l1.val + n) / 10;
            }
            else if (l1 != null && l2 != null) {
                cur.next = new ListNode((l1.val + l2.val + n) % 10); // 计算当前位的值 
                n = (l1.val + l2.val + n) / 10; // 计算新的进位
            }
            else { // l1和l2全部为空，但是上一位还有进位的情况
                cur.next = new ListNode(n);
                n = 0;
            }
            cur = cur.next;
            if(l1 != null) l1 = l1.next; // 只有两个链表指针不为null时，才能继续向后遍历
            if(l2 != null) l2 = l2.next;
        }

        return head.next;
    }
}
```

