# 剑指offer 21. 调整数组顺序使奇数位于偶数前面

**思路一：**

使用两个指针：奇数指针从数组头开始，偶数指针从数组尾开始。

一次for循环就可以分出奇数和偶数，但是使用了额外的空间。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int[] exchange(int[] nums) {
        int[] res = new int[nums.length];

        int odd = 0, even = nums.length - 1;
        for (int i = 0;i < nums.length;i++) {
            if ((nums[i] & 1) == 1) res[odd++] = nums[i];
            else res[even--] = nums[i];
        }

        return res;
    }
}
```



**方法二：**首尾指针。

首指针，从左到右找到第一个偶数，保证首指针的左边全部都是奇数。

尾指针，从右到左找到第一个奇数，保证尾指针的右边全部都是偶数。

限制条件，首指针下标严格小于尾指针下标。



```java
class Solution {
    public int[] exchange(int[] nums) {
        int i = 0, j = nums.length - 1;

        while (i < j) {
            // 判断里限制i < j，同时排除了指针越界的情况
            while ((i < j) && ((nums[i] & 1) == 1)) i += 1; // 从左向右找到第一个偶数
            while ((i < j) && ((nums[j] & 1) == 0)) j -= 1; // 从右向左找到第一个奇数
            swap(i, j, nums); 
        }
        return nums;
    }

    public void swap(int i, int j, int[] nums) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

}
```



# 剑指offer 29. 顺时针打印矩阵

简单的逻辑，具体细节在实现上。

一圈一圈地遍历数组，使用四个指针 `top` 、`bottom`、`left`、`right`，表示**当前这一圈的行列边界所在的数组下标**



```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0) return new int[]{};
        int m = matrix.length, n = matrix[0].length;
        int top = 0, bottom = m - 1, left = 0, right = n - 1; // top,bottom,left和right表示当前一圈所在的行列的下标
        int[] res = new int[m * n];
        int index = 0;

        while (top <= bottom && left <= right) { // 结束条件，当上边界越过下边界，或者左边界越过右边界时，结束
            for (int j = left; j <= right;j++) { // 从左向右第一行
                res[index++] = matrix[top][j];
            }

            for (int i = top + 1;i <= bottom;i++) { // 从上向下第一列
                res[index++] = matrix[i][right];
            }

            if (top == bottom || left == right) break; // 如果最后一圈只有一行或者一列，后面的循环不再计算，防止重复

            for (int j = right - 1;j >= left;j--) { // 从右向左第二行
                res[index++] = matrix[bottom][j];
            }

            for (int i = bottom - 1;i > top;i--) { // 从下向上第二列
                res[index++] = matrix[i][left];
            }
            top++;
            left++;
            bottom--;
            right--;
        }
        

        return res;
    }
}
```



# 剑指offer 39. 数组中出现次数超过一半的数字

1. 使用HashMap，存储每种数字出现的次数，时间复杂度和空间复杂度都是O(N)
2. 排序数组后，中间的那个数一定是次数超过一半的数字
3. 摩尔投票



```java
class Solution {
    public int majorityElement(int[] nums) {
        int votes = 1, res = nums[0];
        for (int i = 1;i < nums.length;i++) {
            if (votes == 0) {
                res = nums[i];
            }
            
            if (nums[i] == res) votes++;
            else votes--;
            
        }
        return res;
    }
}
```



# 剑指offer 40. 最小的k个数（TopK问题）

1. 最简单的是，对整个数组排序，然后取出前k个数。
2. 使用大根堆，即最大的数在队列头的优先队列，Java中即是 `PriorityQueue`。遍历一遍数组，前k个数直接入队；第k+1个数开始，每次比较遍历到的数字是否比队列头（最大的数）小，如果小，那么出队，将新的较小的数入队。（实测，1和2的消耗的时间差不多）
3. 快排。不需要对整个数组进行排序，只要某一次切分后，基准值左边的数字的个数为k时（即partition返回的是k-1时，说明到下标k-1左侧的数字全部比基准值小，下标k-1右侧的数字全部比基准值大，此时去基准值和其左侧的数字即是最小的k个数了）。
4. 数字范围有限时，直接计数排序。



**排序的代码：**

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    }

    private int[] quickSearch(int[] nums, int lo, int hi, int k) {
        // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
        int j = partition(nums, lo, hi);
        if (j == k) {
            return Arrays.copyOf(nums, j + 1);
        }
        // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
        return j > k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
    }

    // 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
    private int partition(int[] nums, int lo, int hi) {
        int v = nums[lo];
        int i = lo, j = hi + 1;
        while (true) {
            while (++i <= hi && nums[i] < v);
            while (--j >= lo && nums[j] > v);
            if (i >= j) {
                break;
            }
            int t = nums[j];
            nums[j] = nums[i];
            nums[i] = t;
        }
        nums[lo] = nums[j];
        nums[j] = v;
        return j;
    }
}
```



**由于数字的范围已经确定了，直接使用一个大数组覆盖，统计所有数字出现的次数，然后从小到大，找出k个数即可**

**计数排序的代码：**

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 统计每个数字出现的次数
        int[] counter = new int[10001];
        for (int num: arr) {
            counter[num]++;
        }
        // 根据counter数组从头找出k个数作为返回结果
        int[] res = new int[k];
        int idx = 0;
        for (int num = 0;num < counter.length;num++) {
            while (counter[num]-- >0 && idx < k) {  // 一直减到出现的次数为0为止，把重复的数字全部算进去
                res[idx++] = num;
            }
            if (idx == k) break;
        }
        return res;
    }
}

```



# 剑指offer. 和为s的两个数字

由于数组已经排好序了，使用双指针效率更高

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while (i < j) { // 双指针，一个从头开始，一个从尾开始
            int tmp = nums[i] + nums[j]; 
            if (tmp > target) j--;      // 如果数字和大于target，j往左移动一个
            else if (tmp < target) i++; // 如果数字和小于target，i往右移动一个
            else return new int[]{nums[i], nums[j]};
        }

        return new int[0];
    }
}
```



一般情况可以使用HashMap

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0;i < nums.length;i++) {
            int remain = target - nums[i];
            if (!map.containsKey(nums[i])) map.put(remain, nums[i]);
            else return new int[]{map.get(nums[i]), nums[i]};
        }

        return new int[0];
    }
}
```



# 剑指offer 57-II. 和为s的连续正数序列

使用双指针

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        if (target <= 2) return new int[0][0];

        ArrayList<int[]> list = new ArrayList<>();
        int i = 1, j = 2;
        while (i < j && i < target && j < target) {
            int sum = (i + j) * (j - i + 1) / 2;
            if (sum == target) { // 当和等于target时，构造结果数组，添加进list，左边界右移
                int[] tmp = new int[j - i + 1];
                for (int k = i;k <= j;k++) {
                    tmp[k - i] = k;
                }
                list.add(tmp);
                i++;
            }
            else if (sum < target) { // 如果和小于target，右边界右移
                j++;
            }
            else { // 如果和大于target，左边界右移
                i++;
            }
        }

        return list.toArray(new int[list.size()][]);
    }
}
```

