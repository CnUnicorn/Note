# 树的递归结构（个人理解）

**向二叉搜索树中的插入操作：**

递归终止条件

1. 对当前节点的操作
2. 向左（右）子树递归，并更新根节点的左节点的指针
3. 向右（左）子树递归，并更新根节点的右节点的指针
4. 更新根节点的指针（**因为函数返回更新后的根节点的指针，所以最后还需要一条返回，否则递归无法返回**）



# 面试题 17.12. BiNode

题目采用输出方式是层序遍历。

思路：

(1、2步骤可以调换)

1. 将当前指针（根节点root）的左节点置空 ```root.left = null```
2. 将前置指针（prev）的右节点指向当前节点 ```prev.right = root```
3. 将前置指（prev）针移到当前节点的位置 ```prev = root```

**难点：**

第一个头节点该如何保存？

初始化两个成员变量（属性），一个额外的节点head、一个前置指针prev（初始化为null）。

将prev初始化为null，通过判断prev是否为空来判断是否为第一个头节点。

使用一个额外的节点，将它的右节点指向第一个头节点。

解决第一个头节点的保存问题后，后面的逻辑即为上面的思路。



# 104. 二叉树的最大深度

使用递归的思路：

**后序遍历整棵树(DFS)**

**整棵树的最大深度 = max（当前根节点左子树的深度，当前根节点右子树的深度） + 1**

上述逻辑可以使用递归完成：

递归终止条件，当前节点为空（没有高度），返回0。

递归是从下（叶子节点）到上（整棵树的root）的

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    ldepth = maxDepth(root.left);
    rdepth = maxDepth(root.right);
    
    return Math.max(ldepth, rdepth) + 1;
}
```



# 面试题04.02. 最小高度树

为了让二叉搜索树的高度尽量小，需要左子树和右子树的节点数量尽量相同。

所以每次插入时，插入数组中的中位数（数组已经排序，所以这个中位数是数组中间的那个值）。

思路（先序遍历，递归）：

1. 以数组的中间值（mid）作为根节点。左子数组构建左节点，右子数组构建右节点
2. 向左子数组递归，向树中插入左子数组的的中间值（重复第一步）
3. 向右子数组递归，向树中插入右子数组的中间值（重复第一步）

即左子树的根节点是左子数组的中位数，右子树的根节点是右子树的中位数，保证了子树的左右子树数量都尽可能相同。



# 剑指Offer 55 - II. 平衡二叉树

**判断一颗二叉树是否平衡**：

任意节点的左右子树高度相差不超过1。

树的深度（高度） = 二叉树中最大深度（离根节点最远的子节点的路径 + 1）

是 **104.二叉树最大深度** 和 **面试题55 - I.二叉树的深度** 的扩展。

* **某一个节点为根节点子树的深度** = max（左子树深度，右子树深度）+ 1



通过辅助函数 `height( )` 计算子树的高度，判断所有节点的左右子树高度差不超过1。

思路：

前序遍历 + 判断所有节点左右子树的高度差值不大于1



**代码逻辑：**

递归终止条件：节点为空，返回true。

**节点为空有两种情况：**

* 根节点为空，树中无节点
* 穿过叶子节点，无子节点
* 只有一个子节点的节点（左右子树高度差 = 1，满足平衡条件）

当前节点为根节点的子树平衡条件（与，即以下三个条件全部都要满足）：

* 左子树高度和右子树高度差值不大于1
* 左子树平衡
* 右子树平衡



# 剑指Offer 55 - I. 二叉树的深度

> 树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；
>
> 常见的 DFS ： 先序遍历、中序遍历、后序遍历；
> 常见的 BFS ： 层序遍历（即按层遍历）。

求树的深度需要遍历树的所有节点，有基于 后序遍历（DFS） 和 层序遍历（BFS） 的两种解法。



**思路一：使用递归的后序遍历（DFS），速度快**

根节点所在子树的高度  =  左子树和右子树高度的最大值 + 1



代码递归逻辑：

递归终止条件：根节点为null，说明穿过了叶子节点，返回0（没有高度）

1. 向左子树递归
2. 向右子树递归
3. 当前节点的高度 = max（左子树的高度，右子树的高度）+ 1



典型的后序遍历递归，对当前根节点的操作在最后。

时间复杂度：O(N)，需要遍历每个节点

空间复杂度：最差的情况下是O(N)，树为线性链表的时候，递归深度为N



**思路二：使用队列的层序遍历（BFS）**

使用一个主队列和一个辅助队列，主队列不为空的时候，一直遍历主队列

每次遍历主队列的时候，将每个节点的左右子节点添加到辅助队列中。

遍历完毕后（遍历了一层），将主队列的指针指向辅助队列，高度加一。

**（广度优先遍历的思想：主队列中一直有值存在，且主队列中的值都在同一层上，距离根节点的距离相同，每遍历一次主队列，就走过了一层）**



# 111. 二叉树的最小深度

思路和最大深度（104）相同，同样是用后序遍历（DFS）来递归计算最小深度。

但是有一个注意点：

如果单纯返回左子树和右子树高度的最小值，**如果有一个子节点为空（那个节点的子树高度一定为0）**，两者取最小直接返回0，那么不为空的那个子树的高度会被直接忽略。

所以需要做额外的判断：

递归结束条件：节点为空，返回0（穿过叶子节点）

1. 递归左子树的最小高度，left

2. 递归右子树的最小高度，right

3. 如果，左右节点有一者为空，或者两者都为空，返回 **left + right + 1**（**实际上是返回不为空的那个节点的子树最小高度 + 1，直接用相加可以省去判断返回哪颗不为空的子树高度**）

4. 如果，左右节点都不为空，返回 **max（左子树高度，右子树高度）+ 1**

   ```java
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) return 0;
           
           int left = minDepth(root.left);
           int right = minDepth(root.right);
           // 当左节点和右节点有一个为空或者两者都为空时，为空的子节点高度为0
           // 所以只要返回不为空的那个节点的最小高度
           if (root.left == null || root.right == null) return left + right + 1; 
           return Math.min(left, right) + 1;
       }
   }
   ```




# 108. 将有序数组转换为二叉搜索树

本质上逻辑和  **面试题04. 02. 最小高度树**  相同，为了让二叉搜索树是平衡的，每次插入数组中的中位数，且左子树在数组中，中位数的左边递归；右子树在数组中，中位数的右边递归。

这样既满足了二叉搜索树的性质（左节点小于根节点，右节点大于根节点），又保证了平衡性。



递归逻辑：**采用先序遍历（新建节点）**

递归终止条件：当超出数组的边界时（lo > hi），返回空（不再新建节点）

1. 如果节点为空，取中位数，新建节点并初始化
2. 向左子数组递归，左节点 = 向左子数组递归
3. 向右子数组递归，右节点 = 向右子数组递归



# 617. 合并二叉树

**1. 使用深度优先搜索（递归方式）**

思路，三种情况：

1. 两个节点中，有一个节点为空，保留不为空的那个节点（返回不为空的节点）

2. 两个节点都不为空，合并两个节点的值，显式地合并（新建一个新的节点）

3. 对新的节点的左右节点进行递归

   **1.没有复用原来的节点：**

   ```java
   public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
       // 其中一个节点为空，保留另一个节点
       if (t1 == null) return t2;
       if (t2 == null) return t1;
       // 两个节点都不为空，合并两个节点的值
       TreeNode merged = new TreeNode(t1.val + t2.val);
       merged.left = mergeTrees(t1.left, t2.left);
       merged.right = mergeTrees(t1.right, t2.right);
   
       return merged;
   }
   ```

   **2.复用了原来的节点**

   ```java
   public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
           // 其中一个节点为空，保留另一个节点
           if (t1 == null) return t2;
           if (t2 == null) return t1;
           // 两个节点都不为空，合并两个节点的值
           t1.val += t2.val;
           t1.left = mergeTrees(t1.left, t2.left);
           t1.right = mergeTrees(t1.right, t2.right);
   
           return t1;
       }
   ```

   

# 783. 二叉搜索树节点最小距离

一开始，采用的思路是，最小距离只可能出现在根节点和左右节点的差值中（采用了先序遍历，优先深度搜索）。后来发现并不是这样，比如下面这种情况，最小距离是90和89的差值。**采用这种思路遗漏了左子树最大值和根节点的差值，和右子树的最小值和根节点的差值**

正确的思路应该是，按顺序查找（中序遍历），然后比较相邻节点的节点的差值是否是当前最小值。

![image-20200924092428593](笔记图片/树/image-20200924092428593.png)

**递归思路**：

递归终止条件：根节点为空，返回（当前节点穿过叶子节点）

1. 向左子树递归
2. 判断是否是第一个节点，即lastVal是否为null。如果为null，说明是第一个节点，把当前节点值保存给lastVal；如果不为null，说明不是第一个节点，上一个节点有值，得到两节点的差值。
3. 向右子树递归

一开始使用了int lastVal = Integer.MIN_VALUE做了标记，把int替换成Integer后，如果没有值，lastVal就是null。使用包装类型来做初始值标记，更为清楚。

```java
private int minDiff = Integer.MAX_VALUE;
private Integer lastVal;

public int minDiffInBST(TreeNode root) {
    helper(root);
    return minDiff;
}

public void helper(TreeNode root) {
    if (root == null) return;
    helper(root.left);

    if (lastVal != null) {
        int diff = root.val - lastVal;
        if (diff < minDiff) minDiff = diff;
    } 
    lastVal = root.val;

    helper(root.right);
}
```



# 100. 相同的树

思路：

相同的树要保证两点：1.结构相同，2.节点值相同



代码递归思路：（先序遍历，DFS）

递归终止条件：两者都为null，说明越过叶子节点，返回true（说明前面的结构与节点值都相同）

1. 排除两者都为null后，判断结构是否相同，即两个节点中有一个为null，一个不为null。如果是，说明结构不同，返回false

2. 排除结构不同之后，最后判断节点值是否相同。如果不相同返回false。

3. 递归左子树和右子树是否为相同的树。如果左右子树都是相同的树，返回true，否则返回false。

   ```java
   public boolean isSameTree(TreeNode p, TreeNode q) {
       if (p == null && q == null) return true;
       if (p == null || q == null) return false;
       if (p.val != q.val) return false;
   
       boolean l = isSameTree(p.left, q.left);
       boolean r = isSameTree(p.right, q.right);
   
       return (l && r);
   }
   ```

   

# 101. 对称二叉树

递归思路：

判断一棵树是否对称，需要递归判断它的左右子树是否对称。

判断两棵树对称的方法：

* 根节点值相同
* 每个树的左子树和另一个树的右子树对称

使用同步移动两个指针（p，q）的方法来遍历整棵树，p右移时，q左移，p左移时，q右移。每次检查p，q值是否相同，再判断左右子树是否对称。



递归终止条件：

* 两个节点都为null，返回true（穿过叶子节点，或者某个两个子节点中某一个节点为null）

* 两个节点其中有一个为null，返回false，结构不对称
* 如果两个节点都不为空，判断节点值是否相同，递归一个节点的左子树和另一个节点的右子树是否对称



```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    else {
        return check(root.left, root.right);
    }

}

public boolean check(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;

    return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
}
```



# 107. 二叉树的层序遍历II

这里需要从最后一层开始层序遍历。

一开始，我想了个笨方法，使用两个存放List的List来实现倒序，相当于用两个队列实现了栈。但是这样很花时间，并且使用了额外的空间。

优化：

1. 对每一层遍历的时候，将节点的数值存放在ArrayList中，而不是LinkedList中，因为只需要存储，不需要查询和插入，所以选择数组形式的列表是最快的。

2. 层序遍历的时候，实现队列的复用，直接将下一层的节点直接入队，每一层只出队这一层节点数量的节点。

3. 最重要的一点，实现倒序：每一层遍历完之后，将当前层的节点值列表添加到列表的头部，而不是添加到列表的尾部（实现了栈的功能）。

4. 实现列表头部插入有两种选择：

   * 使用List接口，`void add(int index, E element)` ，在指定位置插入元素，

     使用`add(0, E element)`，就实现了在列表头部插入元素。

   * 使用双向链表LinkedList( )，使用 `addFirst(E element)` 在头部插入元素。

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {

    if (root == null) {return new LinkedList<List<Integer>>();}
    Queue<TreeNode> queue = new LinkedList<>();
    LinkedList<List<Integer>> listQueue = new LinkedList<List<Integer>>();
    queue.add(root);
    listQueue.add(new LinkedList<Integer>(){{add(root.val);}});

    while (!queue.isEmpty()) {
        List<Integer> nums = new ArrayList<>();
        int length = queue.size();
        for (int i = 0;i < length;i++) {
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.add(node.left);
                nums.add(node.left.val);
            }
            if (node.right != null) {
                queue.add(node.right);
                nums.add(node.right.val);
            }
        }
        if (!nums.isEmpty()) listQueue.addFirst(nums);
    }

    return listQueue;
}
```



# 112. 路径综合

这一题的关键是**区分叶子节点和非叶子节点**，因为题目问的是根节点到叶子节点的路径。

* **叶子节点：**两个子节点都为空。`root.left == null && root.right == null`
* **非叶子节点：**一个子节点为空，或者两个子节点都不为空。`root.left != null || root.right != null`



DFS（递归思路）：

先序遍历，

**每递归一个节点，都把初始的sum值减掉当前节点的值。**

* 如果是叶子节点，判断当前sum是否和叶子节点的值相同。

* 如果不是叶子节点，递归判断，在左右子树中是否存在一条路径满足和等于**sum - root.val**。

**递归终止条件**：

1. 如果根节点为空，返回false。这里的根节点为空判断不是越过叶子节点，而是对空树的判断。
2. 如果是叶子节点，不继续递归，判断sum是否等于当前节点的值
3. 如果不是叶子节点，递归判断左右子树是否hasPath(sum - root.val)，只要左右子树其中有一者满足，就返回true（左右子树递归结果的或）。

```java
public boolean hasPathSum(TreeNode root, int sum) {
    return helper(root, sum);
}

boolean helper(TreeNode root, int sum) {
    if (root == null) return false;

    if (root.left == null && root.right == null) return root.val == sum;   // 叶子节点

    return helper(root.left, sum - root.val) || helper(root.right, sum - root.val);   // 非叶子节点，一个子节点为空或子节点都不为空
```





BFS（非递归思路）：

使用两个队列，一个队列存储节点，一个队列存储从**根节点到当前节点的路径和**，

每次两个队列一起出队，判断出队的节点是否是叶子节点：

* 如果是叶子节点，判断路径和是否和sum相同。如果相同结束循环，返回true；如果不相同，返回继续循环。
* 如果不是叶子节点，继续入队左右子节点，将他们的值加到他们的根节点的路径和上并入队。



# 226. 翻转二叉树

思路，**先序遍历（DFS）**：

新建一颗二叉树，先序遍历原来的二叉树，原二叉树的左节点的值为新二叉树右节点的值（个人认为也可以这么理解，旧二叉树向左子树递归时，翻转后的新二叉树需要向右子树递归）。



**细节：**

先序遍历时，**一定要new一个和当前根节点值相同的节点，指向不同的实例**。而不能直接将当前节点指向旧的节点。如果直接指向旧的节点，那么递归会导致旧节点的左子节点直接指向右子节点（或者右子节点直接指向左子节点）。这样就直接修改了原来的子树，导致结果不正确，也不会报错。

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    // 如果这里指针直接指向了原来的节点，下面的递归相当于原树的左子节点也指向了右子节点
    // 会导致根节点每一层对的其他节点都和最右边的那个节点相同。
    // 实际上是，根节点的左节点先指向了右节点；然后右节点又重复递归指向了左节点
    // TreeNode inverseNode = root; 
    TreeNode inverseNode = new TreeNode(root.val);
    inverseNode.left = invertTree(root.right);
    inverseNode.right = invertTree(root.left);

    return inverseNode;
}
```

> 会导致根节点的左子树的右半部分和左半部分相同，根节点的右子树的左半部分和右半部分相同。

比如，测试用例[4,2,7,1,3,6,9]，翻转后会变成[4,7,7,9,9,9,9]。



# 235. 二叉搜索树的最近公共祖先

思路一，遍历两次二叉树：

由于是BST，**可以很快找到到达某个节点的路径，不需要像普通二叉树一样遍历整颗二叉树，并且可以保存到达它的路径**

遍历两次二叉树，找出到达两个指定节点的路径。两个节点的公共祖先是这两条路径的**分岔点**，也就是最后一个相同的节点。如果把路径节点存储到一个列表中（ArrayList），公共祖先就是满足下面这个条件，下标最大的那个节点：
$$
path[i] = pathq[i]
$$


思路二：

核心思路和思路一相同，也是找到**分岔点**。

按下列思路一次遍历，就能找到分岔点，并且可以不使用递归。只需一次遍历就找出公共节点的原因是BST的性质，左节点小于根节点，右节点大于根节点，恰好和分岔点的两种情况对应。

**分岔点有两种情况**：

1. 两个节点在不同的子树中。
2. 其中一个节点在另一个节点的子树中（在上层的那个节点就是最近公共祖先）。



**代码思路，分成三种情况**：

* p，q值都比当前节点的值大（严格大于），说明p，q都在当前节点的右子树

* p，q值都比当前节点的值小（严格小于），说明p，q都在当前节点的左子树

* 上面两种情况以外，说明当前节点就是分岔点

  仔细讨论最后一种情况，为分岔点的几种情形：

  * p节点和q节点，一个在当前节点的左子树，一个在当前节点的右子树，说明在这个节点它们的路径分开了，所以这个节点是分岔点
  * p节点和q节点，一个值等于当前节点值，说明当前节点为p，q中的其中一个，另一个节点不论在左子树，还是在右子树，它都在另一个节点的子树中，所以当前节点就是分岔点。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (true) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        }
        else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        }
        else {
            return root;
        }
    }
}
```



# 257. 二叉树的所有路径

使用DFS（先序遍历）



主要是判断是不是叶子节点，如果是叶子节点，那么将最后拼接的字符串添加到StringBuilder（因为字符串经常需要拼接，所以使用StringBuilder比使用String要快很多）



递归思路：

递归终止条件：如果节点是空，返回，不添加任何字符串；如果是叶子节点，将当前节点值添加进字符串，并把路径字符串加入List中，返回；

如果不是叶子节点，则把当前的节点值添加进路径字符串中，并添加"->"符号。

然后向左子树和右子树递归。

```java

class Solution {

    private List<String> result;

    public List<String> binaryTreePaths(TreeNode root) {
        String s = "";
        result = new ArrayList<>();
        hepler(root, s);
        return result;
    }

    public void hepler(TreeNode root, String s) {
        if (root == null) return; // 空节点
        if (root.left == null && root.right == null) { // 判断是否是叶子节点
            StringBuilder ss = new StringBuilder(s);
            ss.append(root.val);
            result.add(ss.toString()); // 叶子节点，添加最终的路径字符串
            return;
            }
        StringBuilder ss = new StringBuilder(s); // 不是叶子节点
        ss.append(root.val);
        ss.append("->");
        s = ss.toString();
        hepler(root.left, s);
        hepler(root.right, s);
    }
}
```



# 404. 左叶子之和

这道题没有研究别人的题解。

个人思路

1. 首先判断是否是叶子节点
2. 在判断是叶子节点的基础上，还要另外判断是否是左叶子节点
3. 为了判断是否是左叶子节点，我在参数里多加了一个isLeft变量，指示下一个节点相对当前节点是否是左节点。
   * 向左节点递归的时候，isLeft为true，有可能是左叶子节点
   * 向右子节点递归的时候，isLeft为false，下一个节点必定不为右叶子节点



helper递归终止条件：

如果节点为空(说明穿过了叶子节点），不对sum进行累加。

如果是叶子节点，且为左叶子节点(isLeft=true)，对sum进行累加。

```java
class Solution {

    private int sum = 0;

    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        helper(root.left, true);
        helper(root.right, false);
        return sum;
    }

    public void helper(TreeNode root, boolean isLeft) {
        if (root == null) return;
        if (root.left == null && root.right == null && isLeft) {
            sum += root.val;
        }
        helper(root.left, true);
        helper(root.right, false);
    }
}
```

