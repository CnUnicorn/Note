# 树的递归结构（个人理解）

**向二叉搜索树中的插入操作：**

递归终止条件

1. 对当前节点的操作
2. 向左（右）子树递归，并更新根节点的左节点的指针
3. 向右（左）子树递归，并更新根节点的右节点的指针
4. 更新根节点的指针（**因为函数返回更新后的根节点的指针，所以最后还需要一条返回，否则递归无法返回**）



# 面试题 17.12. BiNode

题目采用输出方式是层序遍历。

思路：

(1、2步骤可以调换)

1. 将当前指针（根节点root）的左节点置空 ```root.left = null```
2. 将前置指针（prev）的右节点指向当前节点 ```prev.right = root```
3. 将前置指（prev）针移到当前节点的位置 ```prev = root```

**难点：**

第一个头节点该如何保存？

初始化两个成员变量（属性），一个额外的节点head、一个前置指针prev（初始化为null）。

将prev初始化为null，通过判断prev是否为空来判断是否为第一个头节点。

使用一个额外的节点，将它的右节点指向第一个头节点。

解决第一个头节点的保存问题后，后面的逻辑即为上面的思路。



# 104. 二叉树的最大深度

使用递归的思路：

**整棵树的最大深度 = max（当前根节点左子树的深度，当前根节点右子树的深度） + 1**

上述逻辑可以使用递归完成：

递归终止条件，当前节点为空（没有高度），返回0。

递归是从下（叶子节点）到上（整棵树的root）的

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    ldepth = maxDepth(root.left);
    rdepth = maxDepth(root.right);
    
    return Math.max(ldepth, rdepth) + 1;
}
```



# 面试题04.02. 最小高度树

为了让二叉搜索树的高度尽量小，需要左子树和右子树的节点数量尽量相同。

所以每次插入时，插入数组中的中位数（数组已经排序，所以这个中位数是数组中间的那个值）。

思路：

1. 以数组的中间值（mid）作为根节点。左子数组构建左节点，右子数组构建右节点
2. 向左子数组递归，向树中插入左子数组的的中间值（重复第一步）
3. 向右子数组递归，向树中插入右子数组的中间值（重复第一步）

即左子树的根节点是左子数组的中位数，右子树的根节点是右子树的中位数，保证了子树的左右子树数量都尽可能相同。



# 剑指Offer 55 - II. 平衡二叉树

**判断一颗二叉树是否平衡**：

任意节点的左右子树高度相差不超过1。

树的深度（高度） = 二叉树中最大深度（离根节点最远的子节点的路径 + 1）

是 **104.二叉树最大深度** 和 **面试题55 - I.二叉树的深度** 的扩展。

* **某一个节点为根节点子树的深度** = max（左子树深度，右子树深度）+ 1



通过辅助函数 `height( )` 计算子树的高度，判断所有节点的左右子树高度差不超过1。

思路：

前序遍历 + 判断所有节点左右子树的高度差值不大于1



**代码逻辑：**

递归终止条件：节点为空，返回true。

**节点为空有两种情况：**

* 根节点为空，树中无节点
* 穿过叶子节点，无子节点
* 只有一个子节点的节点（左右子树高度差 = 1，满足平衡条件）

当前节点为根节点的子树平衡条件（与，即以下三个条件全部都要满足）：

* 左子树高度和右子树高度差值不大于1
* 左子树平衡
* 右子树平衡