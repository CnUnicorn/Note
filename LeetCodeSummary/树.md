# 树的递归结构（个人理解）

**向二叉搜索树中的插入操作：**

递归终止条件

1. 对当前节点的操作
2. 向左（右）子树递归，并更新根节点的左节点的指针
3. 向右（左）子树递归，并更新根节点的右节点的指针
4. 更新根节点的指针（**因为函数返回更新后的根节点的指针，所以最后还需要一条返回，否则递归无法返回**）



# 面试题 17.12. BiNode

题目采用输出方式是层序遍历。

思路：

(1、2步骤可以调换)

1. 将当前指针（根节点root）的左节点置空 ```root.left = null```
2. 将前置指针（prev）的右节点指向当前节点 ```prev.right = root```
3. 将前置指（prev）针移到当前节点的位置 ```prev = root```

**难点：**

第一个头节点该如何保存？

初始化两个成员变量（属性），一个额外的节点head、一个前置指针prev（初始化为null）。

将prev初始化为null，通过判断prev是否为空来判断是否为第一个头节点。

使用一个额外的节点，将它的右节点指向第一个头节点。

解决第一个头节点的保存问题后，后面的逻辑即为上面的思路。



# 104. 二叉树的最大深度

使用递归的思路：

**后序遍历整棵树(DFS)**

**整棵树的最大深度 = max（当前根节点左子树的深度，当前根节点右子树的深度） + 1**

上述逻辑可以使用递归完成：

递归终止条件，当前节点为空（没有高度），返回0。

递归是从下（叶子节点）到上（整棵树的root）的

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    ldepth = maxDepth(root.left);
    rdepth = maxDepth(root.right);
    
    return Math.max(ldepth, rdepth) + 1;
}
```



# 面试题04.02. 最小高度树

为了让二叉搜索树的高度尽量小，需要左子树和右子树的节点数量尽量相同。

所以每次插入时，插入数组中的中位数（数组已经排序，所以这个中位数是数组中间的那个值）。

思路（先序遍历，递归）：

1. 以数组的中间值（mid）作为根节点。左子数组构建左节点，右子数组构建右节点
2. 向左子数组递归，向树中插入左子数组的的中间值（重复第一步）
3. 向右子数组递归，向树中插入右子数组的中间值（重复第一步）

即左子树的根节点是左子数组的中位数，右子树的根节点是右子树的中位数，保证了子树的左右子树数量都尽可能相同。



# 剑指Offer 55 - II. 平衡二叉树

**判断一颗二叉树是否平衡**：

任意节点的左右子树高度相差不超过1。

树的深度（高度） = 二叉树中最大深度（离根节点最远的子节点的路径 + 1）

是 **104.二叉树最大深度** 和 **面试题55 - I.二叉树的深度** 的扩展。

* **某一个节点为根节点子树的深度** = max（左子树深度，右子树深度）+ 1



通过辅助函数 `height( )` 计算子树的高度，判断所有节点的左右子树高度差不超过1。

思路：

前序遍历 + 判断所有节点左右子树的高度差值不大于1



**代码逻辑：**

递归终止条件：节点为空，返回true。

**节点为空有两种情况：**

* 根节点为空，树中无节点
* 穿过叶子节点，无子节点
* 只有一个子节点的节点（左右子树高度差 = 1，满足平衡条件）

当前节点为根节点的子树平衡条件（与，即以下三个条件全部都要满足）：

* 左子树高度和右子树高度差值不大于1
* 左子树平衡
* 右子树平衡



# 剑指Offer 55 - I. 二叉树的深度

> 树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；
>
> 常见的 DFS ： 先序遍历、中序遍历、后序遍历；
> 常见的 BFS ： 层序遍历（即按层遍历）。

求树的深度需要遍历树的所有节点，有基于 后序遍历（DFS） 和 层序遍历（BFS） 的两种解法。



**思路一：使用递归的后序遍历（DFS），速度快**

根节点所在子树的高度  =  左子树和右子树高度的最大值 + 1



代码递归逻辑：

递归终止条件：根节点为null，说明穿过了叶子节点，返回0（没有高度）

1. 向左子树递归
2. 向右子树递归
3. 当前节点的高度 = max（左子树的高度，右子树的高度）+ 1



典型的后序遍历递归，对当前根节点的操作在最后。

时间复杂度：O(N)，需要遍历每个节点

空间复杂度：最差的情况下是O(N)，树为线性链表的时候，递归深度为N



**思路二：使用队列的层序遍历（BFS）**

使用一个主队列和一个辅助队列，主队列不为空的时候，一直遍历主队列

每次遍历主队列的时候，将每个节点的左右子节点添加到辅助队列中。

遍历完毕后（遍历了一层），将主队列的指针指向辅助队列，高度加一。

**（广度优先遍历的思想：主队列中一直有值存在，且主队列中的值都在同一层上，距离根节点的距离相同，每遍历一次主队列，就走过了一层）**



# 111. 二叉树的最小深度

思路和最大深度（104）相同，同样是用后序遍历（DFS）来递归计算最小深度。

但是有一个注意点：

如果单纯返回左子树和右子树高度的最小值，**如果有一个子节点为空（那个节点的子树高度一定为0）**，两者取最小直接返回0，那么不为空的那个子树的高度会被直接忽略。

所以需要做额外的判断：

递归结束条件：节点为空，返回0（穿过叶子节点）

1. 递归左子树的最小高度，left

2. 递归右子树的最小高度，right

3. 如果，左右节点有一者为空，或者两者都为空，返回 **left + right + 1**（**实际上是返回不为空的那个节点的子树最小高度 + 1，直接用相加可以省去判断返回哪颗不为空的子树高度**）

4. 如果，左右节点都不为空，返回 **max（左子树高度，右子树高度）+ 1**

   ```java
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) return 0;
           
           int left = minDepth(root.left);
           int right = minDepth(root.right);
           // 当左节点和右节点有一个为空或者两者都为空时，为空的子节点高度为0
           // 所以只要返回不为空的那个节点的最小高度
           if (root.left == null || root.right == null) return left + right + 1; 
           return Math.min(left, right) + 1;
       }
   }
   ```




# 108. 将有序数组转换为二叉搜索树

本质上逻辑和  **面试题04. 02. 最小高度树**  相同，为了让二叉搜索树是平衡的，每次插入数组中的中位数，且左子树在数组中，中位数的左边递归；右子树在数组中，中位数的右边递归。

这样既满足了二叉搜索树的性质（左节点小于根节点，右节点大于根节点），又保证了平衡性。



递归逻辑：**采用先序遍历（新建节点）**

递归终止条件：当超出数组的边界时（lo > hi），返回空（不再新建节点）

1. 如果节点为空，取中位数，新建节点并初始化
2. 向左子数组递归，左节点 = 向左子数组递归
3. 向右子数组递归，右节点 = 向右子数组递归