# 树的递归结构（个人理解）

**向二叉搜索树中的插入操作：**

递归终止条件

1. 对当前节点的操作
2. 向左（右）子树递归，并更新根节点的左节点的指针
3. 向右（左）子树递归，并更新根节点的右节点的指针
4. 更新根节点的指针（**因为函数返回更新后的根节点的指针，所以最后还需要一条返回，否则递归无法返回**）



# 面试题 17.12. BiNode

题目采用输出方式是层序遍历。

思路：

(1、2步骤可以调换)

1. 将当前指针（根节点root）的左节点置空 ```root.left = null```
2. 将前置指针（prev）的右节点指向当前节点 ```prev.right = root```
3. 将前置指（prev）针移到当前节点的位置 ```prev = root```

**难点：**

第一个头节点该如何保存？

初始化两个成员变量（属性），一个额外的节点head、一个前置指针prev（初始化为null）。

将prev初始化为null，通过判断prev是否为空来判断是否为第一个头节点。

使用一个额外的节点，将它的右节点指向第一个头节点。

解决第一个头节点的保存问题后，后面的逻辑即为上面的思路。



# 104. 二叉树的最大深度

使用递归的思路：

**整棵树的最大深度 = max（当前根节点左子树的深度，当前根节点右子树的深度） + 1**

上述逻辑可以使用递归完成：

递归终止条件，当前节点为空（没有高度），返回0。

递归是从下（叶子节点）到上（整棵树的root）的

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    ldepth = maxDepth(root.left);
    rdepth = maxDepth(root.right);
    
    return Math.max(ldepth, rdepth) + 1;
}
```



# 面试题04.02. 最小高度树

为了让二叉搜索树的高度尽量小，需要左子树和右子树的节点数量尽量相同。

所以每次插入时，插入数组中的中位数（数组已经排序，所以这个中位数是数组中间的那个值）。

思路：

1. 以数组的中间值（mid）作为根节点。左子数组构建左节点，右子数组构建右节点
2. 向左子数组递归，向树中插入左子数组的的中间值（重复第一步）
3. 向右子数组递归，向树中插入右子数组的中间值（重复第一步）

即左子树的根节点是左子数组的中位数，右子树的根节点是右子树的中位数，保证了子树的左右子树数量都尽可能相同。