



# 70. 爬楼梯

**思路一：**动态规划

使用f(x)表示爬到第x级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以可以得到下面的式子：
$$
f(x) = f(x-1) + f(x-2)
$$
**公式的个人理解：**

最后一步跨一步 + 跨到第x-1级台阶的方案数 = 跨到第x级台阶的方案数

最后一步跨两步 + 跨到第x-2级台阶的方案数字 = 跨到第x级台阶的方案数

由于最后一步只跨一步，所以最后一步跨一步的组合方式就等于f(x - 1)，跨两步的组合方式就等于f(x - 2)。



正好就是斐波那契数列。

考虑边界问题，考虑从第0级开始往上爬，从0级爬到0级只有一种方案，f(0) = 1

从第0级爬到第1级，只有一种方案，f(1) = 1

使用**滚动数组的思想**把空间复杂度优化成O(1)。

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 0;i < n;i++) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
}
```



思路二和思路三可以看官方题解

**思路二：**矩阵快速幂

**思路三：**特征方程，直接计算多项式



# 53. 最大子序和

使用 f(i) 表示以第 i 个数结尾的**连续子数组的最大和**，所以要求的就是 i 在0到 n - 1 之间的 f(i) 的最大值。

使用 a<sub>i</sub> 表示nums[i]，连续子数组考虑 a<sub>i</sub> 成为单独的一段还是加入 f(i - 1) 对应的那一段，这就取决于 a<sub>i</sub> 和 f(i - 1) + a<sub>i</sub> 的大小，我们希望获得一个比较大的。

得到动态规划转移方程：
$$
f(i) = max\{f(i-1)+a_i, a_i\}
$$
类似**滚动数组**的思想，使用pre来保存 f(i - 1) 的值，每次遍历新的 a<sub>i</sub> ，更新最大值。

每次遍历新的 a<sub>i</sub> 时，如果 f(i - 1) 加上了 a<sub>i</sub> ，比 a<sub>i</sub> 还小，f(i - 1) 就设置成 a<sub>i</sub> ，a<sub>i</sub> 重新作为新的子数组的起点。

因为后面的数再往上加，要保证只大不小，如果前面的字数组的和还不如 a<sub>i</sub> 大，就抛弃前面所有的值，从 a<sub>i</sub> 开始重新作为子数组的起点。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxResult = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxResult = Math.max(pre, maxResult);
        }

        return maxResult;
    }
}
```



# 121. 买卖股票的最佳时机

**思路一：**暴力遍历求解，最直接明了的方法

**思路二：**一次遍历（动态规划）

![](动态规划.assets/cc4ef55d97cfef6f9215285c7573027c4b265c31101dd54e8555a7021c95c927-file_1555699418271)

想象自己真的在买股票，我们肯定希望在历史最低点买入股票：由于我们知道所有的数据，所以可以耍赖皮。

依次遍历数组，记录一个局部最小值 `minPrice`，那么在第 i 天卖出股票时得到的利润就是 `prices[i] - minPrice` 。

遍历的时候不断更新局部最小值和利润，这样遍历一遍数组之后就能得到最大利润。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int minPrice = prices[0], profit = 0;
        for (int i = 0;i < prices.length;i++) {
            // 自己的方案
            // 先计算今天卖出的利润，如果比之前多，就更新利润；然后看今天的价格是不是局部最小
            if ((prices[i] - minPrice) > profit) profit = prices[i] - minPrice;
            if (prices[i] < minPrice) minPrice = prices[i];
            // 下面是官方题解，先一直遍历找到局部最小，然后更新利润
            // if (prices[i] < minPrice) minPrice = prices[i];
            // else if ((prices[i] - minPrice) > profit) profit = prices[i] - minPrice;
        }
        return profit;
    }
}
```









