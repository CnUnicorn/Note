[toc]

# HTTP笔记

## 1. HTTP全称以及其他全称

HTTP全称：HyperText Transfer Protocol，**超文本传输协议**。严谨译名应为“超文本转移协议”，但是前一种说法已约定俗称，所以一般都是说前者。

HTML全称：HyperText Markup Language，**超文本标记语言**。

URL：Uniform Resource Locator，**同意资源定位符**。



## 2. 网络基础TCP/IP

计算机与网络设备要相互通信，就必须基于相同的方法，这种规则就叫协议。

**TCP/IP协议族按层次分成4层**：应用层、传输层、网络层、数据链路层

**分层的好处**：某个地方需要改动设计时，只需要替换变动的层。把各层接口部分规划好之后，每个层内部的设计也能自由改动



### 2.1 TCP/IP分层管理

#### 应用层

应用层决定了向用户提供应用服务时通信的活动。

TCP/IP协议族内预存了各类通用的应用服务。如：FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。

**HTTP协议也处在该层**。



#### 传输层

传输层对上层应用层，提供处于网络中的两台计算机之间的数据传输。

**在传输层中有两个性质不同的协议**：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。



#### 网络层

又名网络互连层。

网络层用来处理在网络上流动的数据包。数据包是网络传输中的最小数据单位。改层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传送给对方。

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。



#### 数据链路层

又名链路层，网络接口层

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡），及光纤等物理可见部分（还包括连接器等一切传输介质）。**硬件上的范畴均在链路层的范围内**。



### 2.2 TCP/IP通信传输流

<img src="E:\typora\笔记图片\HTTP笔记\TCP_IP传输流1.png" style="zoom:50%;" />

<center>TCP/IP通信传输流</center>

<img src="E:\typora\笔记图片\HTTP笔记\TCP_IP传输流2.png" style="zoom:50%;" />

<center><b>封装</b></center>

发送端和接收端传递的数据都是一层一层地传输，数据每经过一层，**必定会被打上一个该层所属的首部信息**。

### 2.3 TCP协议

TCP协议位于传输层，提供**可靠的字节流服务**（Byte Stream Service），将大块数据分割成以**报文段**（segment）为单位的数据包进行管理。

采用**三次握手**（three-way handshaking）的策略。握手过程中使用了TCP标志（flag）——**SYN**（synchronize）和**ACK**（acknowledge）。

<img src="E:\typora\笔记图片\HTTP笔记\三次握手.png" style="zoom:70%;" />

<center><b>三次握手</b></center>



### 2.4 负责域名解析的DNS服务

DNS（Domain Name System）服务和HTTP协议一样位于应用层，提供域名到IP地址之间的解析服务。因为域名对人更容易记忆（如www.baidu.com），而计算机处理IP（数字）更加方便，所以催生除了DNS服务。



### 2.5 通信过程中协议的作用

![](E:\typora\笔记图片\HTTP笔记\通信过程协议的作用.png)

### 2.6 URI和URL

**URI**（Uniform Resource Identifier）：统一资源标识符，用字符串标识某一互联网资源。

**URL**（U你从人们Resource Location）：统一资源定位符，表示资源的地点（互联网上所处的位置）。

**URL是URI的子集**，URI强调给网络资源标记起名，URL是一个确定的地址，通过这个地址可以访问到网络资源。平时访问资源输入的网址是一个URL。

下图是绝对URI的格式：

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609143725384.png" alt="image-20200609143725384" style="zoom:80%;" />

<center><b>绝对URI的格式</b></center>

* 其中登录信息、端口号、片段标识符是可选项。端口号如果省略，则自动使用默认端口号。

* 服务器地址可以是www.baidu.com这种DNS可解析的域名，

  也可以是192.168.1.1这种IPv4地址，

  也可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名。



## 3. 简单的HTTP协议

### 3.1 HTTP请求报文和响应报文

#### 请求报文的构成

* 请求报文由**请求方法（Method）**、**请求URI（Request-URI）**、**协议版本**、**可选的请求首部字段**和**内容实体**组成。

  **注意**：请求首部字段与内容实体间有一个空行。

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609150910831.png" alt="image-20200609150910831" style="zoom: 60%;" />

<center><b>请求报文的构成</b></b></center>

其中，**指定请求URI的方式**有很多种：

* URI为完整的请求URI

  比如：GET http://hackr.jp/index.htm HTTP/1.1

* 在请求首部字段Host中写明网络域名或IP地址

  如上面的报文所示

  

#### 响应报文的构成

* 响应报文由**协议版本**、**状态码（status code）**、**用以解释状态码的原因短语（reson-phase）**、**可选的响应首部字段**、**实体主题主体**构成。

  注意：响应首部字段与主体之间有一个空行。

  <img src="E:\typora\笔记图片\HTTP笔记\image-20200609151502720.png" alt="image-20200609151502720" style="zoom:67%;" />

<center><b>响应报文的构成</b></center>

### 3.2 HTTP是不保存状态的协议

HTTP是一种**无状态（stateless）**协议。协议对于发送过的请求或响应不做持久化处理，即不保存之前发送过的请求或响应。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP设计得比较简单。

使用Cookie技术，能够实现HTTP协议管理状态。比如，用户登录到一家购物网站，跳转到该网站其他页面，不需要重复登录。



### 3.3 HTTP方法（Method）

下面是HTTP1.1中可以使用的方法。

#### GET：获取资源

请求数据会以？的形式隔开，拼接在请求行中（URL中），即**参数携带在URL中**，**不安全**，没有请求实体部分。

HTTP虽然没有规定请求数据的大小，但是浏览器对URL的长度是有限制的，所以GET请求**不能携带大量的数据**。



#### PUT：传输实体主体

请求数据在内容实体中进行发送，即**将数据放在协议的内容实体中**，在URL中看不到具体的请求数据，相比GET请求方式更加安全。适合数据量大的数据发送。但是效率相比GET请求方式较低。



#### PUT：传输文件

PUT方法用来传输文件。但是HTTP/1.1的PUT方法本身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站不使用该方法。

如果配合Web应用程序的验证机制，或架构设计采用**REST（Representational State Transfer，表征状态转移）**标准的同类Web网站，就可能会开放使用PUT方法。



#### HEAD：获得报文首部

HEAD方法与GET方法一样，只是不返回报文的主体部分。用于确认URI的有效性及资源更新的日期时间等。



#### DELETE：删除文件

用来删除文件，与PUT（传输文件）相反。HTTP/1.1的DELETE和PUT方法和PUT方法一样本身不带验证机制，所以一般网站也不适用DELETE方法。当配合Web应用程序的验证机制，或遵守**REST**标准时还是有可能会开放使用的。



#### OPTIONS：询问支持的方法

用来查询针对请求URI指定的资源支持的方法。

如：OPTIONS * HTTP/1.1

用来查询服务器端支持的的HTTP方法种类。



#### TRACE：追踪路径

让Web服务器将之前的请求通信返回给客户端的方法。

一般不使用这个方法，并且这个方法容易引发XST（Cross-Site Tracing，跨站追踪）攻击。



#### CONNECT：要求用隧道协议连接代理

CONNECT方法要求与代理服务器通信时建立隧道，实现用**隧道协议**进行TCP通信。主要使用**SSL（Secure Sockets Layer，安全套接层）**和**TLS（Transfer Layer Security，传输层安全）协议**把通信内容加密后经网络隧道传输。

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609163100273.png" alt="image-20200609163100273" style="zoom: 60%;" />



### 3.2 两个版本HTTP支持的方法

| 方法    | 说明                     | 支持的HTTP协议版本 |
| ------- | ------------------------ | ------------------ |
| GET     | 获取资源                 | 1.0、1.1           |
| POST    | 传输实体主体             | 1.0、1.1           |
| PUT     | 传输文件                 | 1.0、1.1           |
| HEAD    | 获得报文首部             | 1.0、1.1           |
| DELETE  | 删除文件                 | 1.0、1.1           |
| OPTIONS | 查询支持的方法           | 1.1                |
| TRACE   | 追踪路径                 | 1.1                |
| CONNECT | 要求用隧道协议连接代理   | 1.1                |
| LINK    | 建立和资源之间的连接关系 | 1.0                |
| UNLINK  | 断开连接关系             | 1.0                |



### 3.3 持久连接

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。在请求很多的情况下，多次建立断开TCP连接会带来很多不必要的开销。

如图：

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609172727262.png" alt="image-20200609172727262" style="zoom:80%;" />

为解决这个问题，HTTP/1.1和一部分HTTP/1.0想出了**持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）**的方法。只要任意一段没有民却提出断开连接，则保持TCP连接状态。

在HTTP/1.1中，所有连接默认是持久连接，但在HTTP/1.0内并未标准化。

除了服务器端需要支持持久连接，客户端也需要支持持久连接。



### 3.4 管线化

**持久连接**让多数请求以**管线化（pipelining）**方式发送成为可能。

之前发送请求后需要等待并接收到响应，才可以发送下一个请求，**请求发送是串行的**。

持节连接结合管线化技术后，可以同时并行地发送多个请求，相比串行发送地方式，请求能够更快结束，并且请求数越多，能节省的时间也越多。

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609173616614.png" alt="image-20200609173616614" style="zoom:67%;" />

### 3.5 使用Cookies管理状态

使用Cookies技术解决HTTP无状态特性带来的问题。Cookies技术通过在请求和响应报文中写入Cookies信息来控制客户端的状态。

Cookies会根据从服务器端发送的**响应报文**内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后再发出去。

服务器端发现客户端发送过来的**请求报文**中的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

**注意：Cookie是由服务器端先发起的。**

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609174245355.png" alt="image-20200609174245355" style="zoom:80%;" />

<img src="E:\typora\笔记图片\HTTP笔记\image-20200609174304695.png" alt="image-20200609174304695" style="zoom:85%;" />

### 3.6 HTTP交互流程

**1.**客户端和服务器和服务器端建立连接（TCP）

**2.** 客户端发送请求到服务器端（**遵循HTTP协议**）

**3.** 服务器端收到请求后，进行处理，然后将处理结果响应客户端（**遵循HTTP协议**）

**4.** 关闭客户端和服务器端的连接（**HTTP1.1后不会立即关闭，可持续连接**）

上述一个完整的过程称为一个**HTTP消息**



## 4. 报文内的HTTP信息

### 4.1 请求报文和响应报文的结构

下图上面是**请求报文**结构，下面是**响应报文**结构。

请求报文由**请求行**、**首部字段（请求首部字段、通用首部字段、实体首部字段）**、**报文主体**构成。

响应报文由**状态行**、**首部字段（响应首部字段、通用首部字段、实体首部字段）**、**报文主体**构成。

报文主体是实际要传输的数据。

<img src="E:\typora\笔记图片\HTTP笔记\image-20200610162812349.png" alt="image-20200610162812349" style="zoom:80%;" />

### 4.2. HTTP常见响应状态码含义

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分五种类型：

<center>HTTP状态码分类</center>

| 分类 | 分类描述                                         |
| ---- | ------------------------------------------------ |
| 1**  | 信息，服务器收到请求，需要需要请求者继续执行操作 |
| 2**  | 成功，操作被成功接收并处理                       |
| 3**  | 重定向，需要进一步的操作以完成请求               |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求       |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误   |

常见的状态码：

200 OK											//客户端请求成功

301 Moved Permanently             //永久性重定向。表示请求的资源已经被分配了新的URL，以后应使用资源               

​                                                            所指的URL

302  FOUND                                   //临时性重定向。表示请求的资源已被分配了新的URL，希望用户**本次**

​                                                             使用新的URL访问。

400 Bad Request                          //客户端请求有语法错误，不能被服务器所理解

401 Unauthorized                        //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用

403 Forbidden                              //服务器收到请求，但是拒绝提供服务

404 Not Found                              //请求资源不存在，eg：输入错误的URL

500 Internal Server Error            //服务器发生不可预期的错误

503 Server Unavailable               //服务器当前不能处理客户端的请求，一段时间后可能恢复正常









