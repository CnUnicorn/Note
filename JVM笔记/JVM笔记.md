[toc]

# Java中的引用

强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。

四种引用强度一次减弱。

* 强引用：程序代码中普遍存在的引用赋值，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。
* 软引用：描述一些还有用，但非必须的对象。**在系统将要发生内存溢出异常前**（OOM——Out of Memory），会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* 弱引用：也是描述非必须对象，但是比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生为止**。
* 虚引用：一个对象是否存在虚引用，不会对它的生存时间构成影响。唯一目的只是**为了能在这个对象被收集器回收时收到一个系统通知。**



# 垃圾回收算法

## 如何划分堆内存

**堆可以分成两块：**

* 新生代（Young Generatin）
* 老年代（Old Generation）



JDK1.8开始移除永久代，并把**方法区移动至元空间**，它**位于本地内存**中，而不在虚拟机中。

**方法区是JVM的一个规范，元空间和永久代只是实现它的一种方式**。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。**元空间存储类的元信息，静态变量和常量池等放入堆中**。



**部分回收（Partial GC）：**

* 新生代收集（Minor GC）：目标只是新生代的垃圾收集
* 老年代收集（Major GC）：目标只是老年代的垃圾收集
* 混合收集（Mixed GC）：目标是整个新生代和部分老年代的垃圾收集



**整堆收集（Full GC）：**收集整个Java堆和方法区的垃圾收集



## 标记-清除算法（Mark-Sweep）

标记出所有需要回收的对象，标记完成后，统一回收被标记的对象。

最基础的算法，很多算法都是基于标记清除算法进行改进。

**主要缺点：**

* 执行效率不稳定，如果Java堆中包含的对象很多，标记和清除这两个过程的效率会随着对象数量增长而降低
* 空间碎片化问题，标记、清除后**会产生大量不连续的内存碎片。**碎片太多时，可能会导致没有足够的内存空间分配给大对象，导致不得不触发另一次垃圾回收。



## 标记-复制算法（Mark-Copy）

**适合在对象存活率较低的时候使用。**存活率高时，容易产生较大的开销。

**半区复制**：

将内存分成，大小相同的两块。

每次垃圾回收时，将存活下来的对象拷贝到另一块内存上。然后清除原来那部分的整块内存。



改进了，标记-清除算法在可回收对象很多时出现的效率低下问题。

缺点在于：

* 可用内存变成原来的一半
* 如果存活的对象很多，会产生大量的内存开销



**Appel式回收：**

由于新生代大多数的对象都熬不过第一轮垃圾收集，不需要按照1:1的比例来划分新生代空间。

浪费的空间只有10%（其中有一个Survivor是有存活的新生代对象的）。

分成三块区域：

* 一块Eden，占80%的java堆内存
* 两块Survivor，各占10%的Java堆内存

每次垃圾回收，都将Eden和一块Survivor中存活的对象，拷贝到另一块Survivor中。

然后清理掉Eden和使用过的那块Survivor空间。

（使用两块Survivor是因为，Survivor和Eden的比例不是1:1，没有办法直接交换，需要额外的一块Survivor来存储这一次垃圾回收存活的对象）



当Survivor无法容纳一次Minor GC后的对象时，需要依赖其他内存区域（大多数时候是老年代）进行担保分配，对象通过分配担保机制直接进入老年代。



## 标记-整理算法（Mark Compact）

**消除了 标记-清除 算法存在的内存空间碎片问题。**



标记-整理 算法的标记过程和标记-清除算法相同，标记完成后，不是直接清理可回收对象，而是**将所有存活的对象都向内存空间的一端移动，然后清理掉边界以外的内存**。



标记-整理算法，在移动存活对象的时候，需要全程暂停用户的应用程序（ZGC和Shenandoah收集器使用读屏障技术实现了整理过程和用户线程的并行）。

标记-整理 算法相比 标记-清除 算法，在垃圾收集的时候会有停顿；

如果不考虑移动对象，标记-清除 算法，只能依赖更复杂的内存分配器和内存访问器来解决。由于内存访问非常频繁，如果在访问内存时增加额外的开销，从内存整个程序的吞吐量来看，移动对象会更划算。



# 什么时候会发生Full GC

1. 手动调用`System.gc()`

   此方法调用是**建议** JVM 进行Full GC，调用这个方法并非一定会触发Full GC。

2. 老年代空间不足

3. 堆中分配了大对象

   当堆中的大对象进入老年代时，如果老年代仍然有很大的剩余空间，但是无法找到**足够大的连续的空间**来分配给当前对象，这种情况就会触发 JVM 进行 Full GC。







