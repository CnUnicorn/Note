# Unicode 和 UTF-8 的区别

* Unicode是 [ 字符集 ]

* UTF-8是 [ 编码规则 ]

  

字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）

编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）



# 超类变量引用子类对象

超类变量引用子类对象时，不能调用超类中没有而子类中存在的方法。

如果子类中覆写（overwrite）了超类中的方法，那么调用的是覆写（overwrite）后的方法，否则调用超类中原来的方法。

如果为了要使用子类的方法，那么可以**重新将引用了子类的超类对象强转成子类对象**（即恢复成子类对象）。



# foreach无法初始化对象数组

```java
// 声明一个链表数组，但其中的每一个元素（链表）并没有初始化，全部是null
LinkedList<Integer>[] a = (LinkedList<Integer>[]) new LinkedList[10];

for (int i = 0;i < 10;i++) {
    a[i] = new LinkedList<>(); // 需要使用带下标的for循环来对他进行初始化
}

for (LinkedList<Integer> list : a) {
    list = new LinkedList<>(); // 使用foreach循环，无法初始化
}
```

**原因：**

当对量数组是空的时候，比如这里的链表数组，foreach循环变量得到的指针实际上是null。

1. 如果对foreach的变量进行初始化操作，new 某个对象，确实是返回了一个指针，只不过这个指针赋给了foreach中的临时变量，而不是赋给了数组中元素的指针变量。所以并不会对数组初始化成功。
2. 采用带下标的for循环，a[i] 就是数组中元素的指针变量，new 对象之后，返回的指针直接赋给了数组中的元素，所以能够初始化对象。
3. 如果对象数组已经初始化成功了，使用foreach，临时变量拿到的是，数组元素的指针变量，指向堆内存中的实例，是可以修改对象数组中的元素的。（也可以这样说，**foreach可以修改对象数组中对象的内容，而不能修改对象数组中对象的本身**）。



# 包装类型不可变

所有原始的包装类（Integer，Byte，Long，Float，Double，Character，Boolean和Short），在Java中都是不可变的，加法，减法等改变数值的操作实际上是创建了一个新的对象，而不会修改旧的对象。



# Long和int

Java中输入数字默认是int类型，int类型强转成long类型不会丢失信息（32位int直接转成long的低32位）。

如果想要Long类型的数字，可以写成`60L`

int 类型范围：**-2147483648 ~ +2147483647**（左闭右开，左边可以取到2的32次方，右边取到2的31次-1）

**其他类型也是左闭右开**



# >> 和 >>> 的区别

```java
>> 表示带符号右移，符号位不变，次高位开始右移，高位补0
>>> 表示无符号右移，符号位也参与右移，高位补0
```



