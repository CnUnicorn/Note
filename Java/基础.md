# Unicode 和 UTF-8 的区别

* Unicode是一种标准，包含了[字符集]和编码方式（UTF-8，UTF-16，UTF-32等）

* UTF-8是 [ 编码规则 ]，即Unicode的实现方式，维基百科上解释为***\*编码方式（Character Encoding）\****

  Java中char类型占用的字节，取决于采用的编码方式，使用UTF-8，则英文字符占用一个字节，汉字占用三个字节。

字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）

编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）



# 超类变量引用子类对象

超类变量引用子类对象时，不能调用超类中没有而子类中存在的方法。

如果子类中覆写（overwrite）了超类中的方法，那么调用的是覆写（overwrite）后的方法，否则调用超类中原来的方法。

如果为了要使用子类的方法，那么可以**重新将引用了子类的超类对象强转成子类对象**（即恢复成子类对象）。



# foreach无法初始化对象数组

```java
// 声明一个链表数组，但其中的每一个元素（链表）并没有初始化，全部是null
LinkedList<Integer>[] a = (LinkedList<Integer>[]) new LinkedList[10];

for (int i = 0;i < 10;i++) {
    a[i] = new LinkedList<>(); // 需要使用带下标的for循环来对他进行初始化
}

for (LinkedList<Integer> list : a) {
    list = new LinkedList<>(); // 使用foreach循环，无法初始化
}
```

**原因：**

当对量数组是空的时候，比如这里的链表数组，foreach循环变量得到的指针实际上是null。

1. 如果对foreach的变量进行初始化操作，new 某个对象，确实是返回了一个指针，只不过这个指针赋给了foreach中的临时变量，而不是赋给了数组中元素的指针变量。所以并不会对数组初始化成功。
2. 采用带下标的for循环，a[i] 就是数组中元素的指针变量，new 对象之后，返回的指针直接赋给了数组中的元素，所以能够初始化对象。
3. 如果对象数组已经初始化成功了，使用foreach，临时变量拿到的是，数组元素的指针变量，指向堆内存中的实例，是可以修改对象数组中的元素的。（也可以这样说，**foreach可以修改对象数组中对象的内容，而不能修改对象数组中对象的本身**）。



# 包装类型不可变

所有原始的包装类（Integer，Byte，Long，Float，Double，Character，Boolean和Short），在Java中都是不可变的，加法，减法等改变数值的操作实际上是创建了一个新的对象，而不会修改旧的对象。



# Long和int

Java中输入数字默认是int类型，int类型强转成long类型不会丢失信息（32位int直接转成long的低32位）。

如果想要Long类型的数字，可以写成`60L`

int 类型范围：**-2147483648 ~ +2147483647**（左闭右开，左边可以取到2的32次方，右边取到2的31次-1）

**其他类型也是左闭右开**



# float和double

Java里输入 0.0，默认的是double，如果要float，写成0.0f。

# >> 和 >>> 的区别

```java
>> 表示带符号右移，符号位不变，次高位开始右移，高位补0
>>> 表示无符号右移，符号位也参与右移，高位补0
只有无符号右移，没有无符号左移，即没有 <<<
```



# HashMap的一些注意点

* HashMap**默认的长度是16**。

* JDK1.8中，**链表转换成红黑树的情况**：

  * 当**链表长度超过8时**，先判断table长度是否小于64，如果**长度小于64**，先通过扩容的方法解决冲突；如果**长度大于64**，通过把链表转换成红黑树解决冲突。

  * 链表长度大于8的情况：

    * table长度足够，hash冲突过多

    * hash没有冲突，但是在计算table下标的时候，由于table长度太小，导致很多hash不一致的key计算的下标一致

    * **第二种情况是可以通过扩容来解决的，所以先判断table的长度是否小于64**

      

* JDK1.8中，**红黑树转换成链表的情况：**

  * hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。



* a mod(%) b，模运算的消耗还是比较大的。

  **HashMap源码中使用位操作代替取模，加快速度**

  HashMap源码中固定链表数组长度为2的幂次，所以使用`a & (b - 1)` **等价于对length取模**，加快取模操作。



在JDK1.7中由于链表使用头插法，在并发的情况下有可能会导致循环链表的产生。在JDK1.8中进行了优化，每个bucket（即数组中的每条链表），使用了 loHead、loTail（保存数组下标不变化的节点链表）和hiHead、hiTail（保存移动到，原下标+oldCap，位置上的节点），不会导致循环链表的产生，但是会出现数据损失（有可能其他线程的hiHead还是null，在这个线程扩容的时候，可能会覆盖其他线程已经扩容完成的数组，导致数据损失）。



**如何解决哈希冲突？**

![img](https://upload-images.jianshu.io/upload_images/944365-7621b15f58e87a66.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

* 如何避免（预防）Hash冲突：
  1. 扩容，有可能Hash值都是不一样的，但是数组长度太小，导致很多hash值不同的键，最后计算得到的下标全部都是一样的。
  2. 好的Hash算法。
* 如果发生了Hash冲突，解决方案：
  1. 数据结构和良好的数据存储机制，比如链表和红黑树（即映射到了同一个数组下标上），不需要重新Hash，尾插法（使用loHead、loTail保存数组下标不变的节点；使用hiHead、hiTail保存数组下标需要加上oldCap的节点）



# 基本数据类型数组默认的初始值

```java
int[]       // 默认所有值为0
boolean[]   // 默认所有值为false
double[]    // 默认所有值为0.0
```



# 自动类型转换规则

低级的类型向更高级的类型转换。

![image-20201216092854920](基础.assets/image-20201216092854920.png)



# ConcurrentHashMap

ConcurrentHashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。

1. 如果没有初始化就先调用initTable（）方法来进行初始化过程
2. **如果没有hash冲突就直接CAS插入**
3. 如果还在进行扩容操作就先进行扩容
4. **如果存在hash冲突，就加锁来保证线程安全**，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，
5. 最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环
6. 如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容



# hashCode方法与equals方法（HashMap）

 `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址 转换为整数之后返回。

* 两个对象内容相同，那么他们的hashcode一定也是相同的，所以重写equals方法的时候，也要重写hashCode方法，否则默认使用的是Object类中的hashCode方法，导致两个对象相同，但是他们的hashCode不同。
* 两个对象不同，他们hashCode可能是相同的



在HashMap中，判断键是否相同，判断逻辑是，先判断hashCode是否相同，如果hashCode相同，再通过equals判断，这两个键是否真的相同，如果是相同的键，才会覆盖值。**所以自定义对象的时候，需要重写hashCode和equals对象**。



# 8 种基本类型的包装类和常量池

Java 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。

**Integer 缓存源码：**

```java
/**

*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。

*/

public static Integer valueOf(int i) {

    if (i >= IntegerCache.low && i <= IntegerCache.high)

      return IntegerCache.cache[i + (-IntegerCache.low)];

    return new Integer(i);

}

private static class IntegerCache {

    static final int low = -128;

    static final int high;

    static final Integer cache[];

}
```



```java
Integer i1 = 40;

Integer i2 = new Integer(40);

System.out.println(i1==i2);
```

`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是常量池中的对象。而`Integer i1 = new Integer(40)` 会直接创建新的对象。



**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

![img](https://camo.githubusercontent.com/1787ac3ea56e56450b185b8e6dccb0bfd4ce60cafe05ffdecf31f3e64c833724/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323136343534343834362e706e67)



# 在一个静态方法内调用一个非静态成员为什么是非法的?

**静态方法先于非静态成员（实例）加载**



这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。



# 重载（overload）与重写（overwrite）

**方法的签名：**

方法的签名（signature），是方法的**名称**和方法参数的**类型**

**注意：**方法的签名不包括方法的返回类型。

```java
indexOf(int, int);
indexOf(int);
indexOf();
```

* 重载（overload）

  发生在编译期。

  1. 重载，是当前类中，有多个**名字相同，参数不同的方法**（返回值可以不同），根据方法签名来匹配调用的方法。
  2. 构造方法可以被重载

  

* 重写（overwrite）

  重写发生在**运行期**，是子类对父类的允许访问的方法的实现过程进行重新编写。

  1. **返回值类型、方法名、参数列表**必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
  3. 构造方法无法被重写

  综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变



重载和重写的区别：

| 区别点     | 重载方法   | 重写方法                                                     |
| ---------- | ---------- | ------------------------------------------------------------ |
| 发生范围   | 同一个类   | 子类                                                         |
| 参数列表   | 必须修改   | 一定不能修改                                                 |
| 返回类型   | 可修改     | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改     | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改     | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | **编译期** | **运行期**                                                   |



# 面向对象三大特征

1. **封装**

   封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。

   

2. **继承**

   不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

    

   **关于继承如下 3 点请记住：**

   1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问（使用super.getXXX()方法调用父类的属性)，**只是拥有**。
   2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
   3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

    

3. **多态**

   多态，顾名思义，表示一个对象具有多种的状态。具体表现为**父类的引用指向子类的实例**。

   **多态的特点:**

   - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
   - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
   - **多态不能调用“只在子类存在但在父类不存在”的方法**；
   - **如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法**。



# 异常

## Java 异常类层次结构图

![img](https://camo.githubusercontent.com/a8e7d0a4e1a10229cafe10d51382e418c9ed75b6bb1b5c82a91be4189916facb/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f4a6176612545352542432538322545352542382542382545372542312542422545352542312538322545362541432541312545372542422539332545362539452538342545352539422542452e706e67)

![img](https://camo.githubusercontent.com/17d2b543fcd5c80208deea27d941b41d7cb868da7172d6cf1e91722b34a86f0b/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f4a617661254535254243253832254535254238254238254537254231254242254535254231253832254536254143254131254537254242253933254536253945253834254535253942254245322e706e67)



在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。

`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 **受检查异常(必须处理) 和 不受检查异常(可以不处理)**。
- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。



## **受检查异常**

Java 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。

![check-exception](https://camo.githubusercontent.com/7d2ee768c0941e60bc0a88f345c92735bba4b785bfd0dcaa436924e3f47fe2a0/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f636865636b2d657863657074696f6e2e706e67)

除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。



## **不受检查异常**

Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。

`RuntimeException` 及其子类都统称为非受检查异常，例如：`NullPointerException`、`NumberFormatException`（字符串转换为数字）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换错误）、`ArithmeticException`（算术错误）等。

